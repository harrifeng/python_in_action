#+OPTIONS: ^:{}
* Chapter 1: A Tutorial Introduction
** Running Python
   + python 有自己的shell, _ 代表是上次的计算结果
     #+begin_example
       Type "help", "copyright", "credits" or "license" for more information.
       >>> 6000 + 3344.23 + 123.4
       9467.63
       >>> _ + 1000
       10467.63
       >>>      
     #+end_example
   + 除了quit()的方式之外，还可以使用raise SystemExit来退出
     #+begin_example
       Type "help", "copyright", "credits" or "license" for more information.
       >>> print "hello world"
       hello world
       >>> raise SystemExit     
     #+end_example

** Variables and Arithmetic Expressions
   + python是一种动态语言，也就是说变量的类型是不固定的。更确切的说，是变量可以指向任意类型的数据
     #+begin_src python
       principal = 1000 ; rate = 0.05 ; numyears = 5
       year = 1principal = 1000 ; rate = 0.05 ; numyears = 5
       year = 1
       while year <= numyears
           principal = principal * ( 1 + rate)
           print "%3d %0.2f" % (year, principal)
           year += 1
     #+end_src
   + python string 的format函数很常用，用法如下
     #+begin_src python
       print format (year, "3d"), format (principal, "0.2f")
       
       # Or it can be used as string's function
       print "{0：3} {1:0.2f}".format(year, principal)
     #+end_src
** Conditionals
   + Condition 也是和常规语言差不多，只不过，python不使用括号，而是使用缩进
     #+begin_src python
       if a < b:
           pass    #Do nothing
       else:
           print "Computer says No"
     #+end_src
   + or, and, not 都是python关键字
     #+begin_src python
       if product == "game" and type == "pirate memory" \
                            and not (age < 4 or age > 8):
           print "I'll take it !"
     #+end_src
   + python没有switch的概念,都是用elif来代替的
     #+begin_src python
       if suffix == ".htm":
           content = "text/html"
       elif suffix == ".jpg":
           content = "image/jpeg"
       elif suffix == ".png":
           content = "image/png"
       else:
           raise RuntimeError("Unknown content type")
     #+end_src
** File Input and Output
   + 下面是一个python读取文件的例子
     #+begin_src python
       f = open("tmp.txt")
       line = f.readline()
       while line:
           # the trailing '.' can delete the last new line,
           # as the print will introduce a new line
           print line,        
           line = f.readline()
       f.close()
     #+end_src
   + 写入文件的时候,我们会用到 >>, 如下例:
     #+begin_src python
       f = open("out", "w")    #open file for writing
       while year <= numyears:
           principal = principal * (1 + rate)
           print >> f, "%3d %0.2f" % (year, principal)
           year += 1
       f.close()
     #+end_src
   + 在c语言里面经常见到的请输入啥啥啥到这里就是如下写法
     #+begin_src python
       import sys
       sys.stdout.write("Enter your name :")
       name = sys.stdin.readlin()
       
       # You can shortened all previous code to one line in Python 2
       
       name = raw_input("Enter your name:")
     #+end_src
** Strings
   + 在python中,单引号,双引号,甚至三引号都能代表字符串,三引号字符串甚至不需要在一行里面
   + 获取子字符串非常简单s[i:j]就可以,而且数字字符串之间相加依然是字符串
     #+begin_src python
       c = a[:5]    #"Hello"
       e = a[3:8]   #"lo Wo"
     #+end_src
   + 想要把字符串转换成数字,要靠1format() 2str() 和3repr(), 其中str()和repr()的区别
     是, str()返回print的结果,repr则是返回机器内部实际的存储方式
     #+begin_src python
       s = "The value of x is " + str(x)
       s = "The value of x is " + repr(x)
       s = "The value of x is " + format(x, "4d")     
       >>> x = 3.4
       >>> str(x)
       '3.4'
       >>> repr(x)
       '3.3999999999999999'
       >>> format(x, "0.5f")
       '3.40000'
     #+end_src
** List
   + List就是python中最常见的数据结构了,用起来也很随意.从0开始index,
     在尾部插入用append, 在任意位置插入用insert
     #+begin_src python 
       names = ["Dave", "Mark", "Ann", "Phil"]
       a = names[2]   # Returns the third item of the list, "Ann"
       names.append("Paula")
       names.insert(2, "Thomas")
     #+end_src
   + list可以包含任意的数据类型,甚至list中含有list
     #+begin_src python 
       a = [1, "Dave", 3.14, ["Mark", 7, 9, [100, 101]], 10]
       
       a[1]             # Retursn "Dave"
       a[3][2]          # Retursn 9
       a[3][3][1]       # Retursn 101
     #+end_src
   + 下面是一个读取文件名,然后找到文件中最大数和最小数的例子,用到了前面的知识
     #+begin_src python 
       import sys
       if len(sys.argv) != 2
           print "Please supply a filename"
           raise SystemExit(1)
       f = open(sys.argv[1])
       lines = f.readlines()
       f.close()
       
       Convert all of the input values from strings to floats
       fvalues = [float(line) for line in lines]
       
       print "The minimum value is ", min(fvalues)
       print "The maximum value is ", max(fvalues)
     #+end_src
** Tuples
   + 从最直观上来看tuples是用(),而list是用[]来创建的.说白了,tuples就是不能增加
     成员的list,常用的tuples方式就是来分配数据. tuples之所以独立出list就是因为
     他的数量不能增长,是固定的,所以消耗内存更少
     #+begin_src python 
       stock = ('COOG', 100, 490.10)
       address = ('www.python.org', 80)
       person = (first_name, last_name, phone)
       
       name, shres, price = stock
       host, port = address
       first_name, last_name, phone = person
     #+end_src
** Sets
   + 和 list以及tuples不同的是,set是一个没有顺序的概念.数学中的集合也是没有顺序的,
     而且set内部是没有重复成员的,同时 set的创建就不是默认[]或者()那么简单了,要使用
     关键字set
     #+begin_src python 
       s = set([3, 5, 9, 10])   # Create a set of numbers
       t = set("Hello")         # Create a set of unique characters
       
       # 从内部输出看,我们注意到set刚好是由()和[]组成的
       >>> t
       set(['H', 'e', 'l', 'o'])
     #+end_src

   + set支持 全集, 交集, 补集 并集
     #+begin_src python 
       a = t | s  # 全集 Union of t and s                                      
       b = t & s  # 交集 Intersection of t and s
       c = t - s  # 补集 Set difference (items in t, but ont in s)
       d = t ^ s  # 并集 Symmetric difference (items in t or s, but not both)
     #+end_src
   + set是可以add, update,和remove的
     #+begin_src python        t.add('x')
       s.update([10, 37, 42])   #Add multiple items to s
       t.remove('H')
     #+end_src
** Dictionaries
   + 在小括号tuples,中括号list之后,大括号终于派上了用场,那就是dictionary.你尽可以把dictionary
     想象成python内置的hash table
   + 既然是hash table,那么就有key和value的概念在里面,":"前面的是key,后面的是value,任何不可变
     的类型(字符,数字,tuples),都可以作为key,最常用的是字符串.所有dictionary的操作都是key-value
     导向的
     #+begin_src python 
       import sys
       
       stock = {
           "name"   :   "GOOG",
           "shares"  :   100,
           "price"  :   1490.10
           }
       stock["shares"] = 50             # update value
       stock["date"] = "June 7, 2007"   # add domain
       
       name = stock["name"]
       value = stock["shares"] * stock["price"]
       
       print name, value
     #+end_src
   + dictionary是一种非常有用(无顺序数据)的查找容器, 通过"in"来进行key值查找
     #+begin_src python
       prices = {
           "GOOG" : 490.10,
           "AAPL" : 123.50,
           "IBM"  : 91.50,
           "MSFT" :52.13,
           }
       
       if "MSFT" in prices:
           p = prices["MSFT"]
       else:
           p = 0
           
       #more compact way to get the value
       p2 = prices.get("SCOX", 0.0)
       
       print p, p2
       
       # convert keys to a list:
       syms = list(prices) #syms = ["AAPL", "MSFT", "IBM", "GOOG"]
       
       # delete an element from dictionary
       del prices["MSFT"]
     #+end_src
** Iteration and Looping
   + 借助range(), for在数字的循环领域可以大显身手
     #+begin_src python
       for n in range(1, 10):
           print "2 to the %d power is %s" % (n, 2**n)
       
       print range(5)
       print range(1,8)
       print range(0, 14, 3)
       print range(8, 1, -1)
     #+end_src
   + 当然,在python擅长的字符串领域,for更能发挥
     #+begin_src python
       import sys
       
       a = "Hello World"
       for c in a:
           #print c   ## with new lines
           #print c,  ## with extra spaces;
           sys.stdout.write(c) ## all clear
       print    
       
       b = ["Dave", "Mark", "Ann", "Phil"]
       for name in b:
           print name
       
       c = { 'GOOG' : 490.10, 'IBM' : 91.50, 'AAPL' : 123.15 }
       for key in c:
           print key, c[key]
     #+end_src
** Functions
   + 在python中,是使用def来创建, 而且由于tuples这种特殊形式的存在,在python function
     中返回两个结果是非常容易的
     #+begin_src python
       def divide(a, b):
           q = a // b   # // is truncating division.
           r = a - q * b
           return (q, r)
       
       quotient, remainder = divide(1526, 30)
       
       print quotient, remainder
     #+end_src
   + 和c语言一样, python在function内部申请的变量是局部变量.
** Generators
   + function可以直接返回一个结果,也可以用tuples返回多个结果,还可以使用yield返回不定个数的
     结果.所有使用yield的function就可以被称作是generator
     #+begin_src python
       def  countdown(n):
           print "Counting down!"
           while n > 0:
               yield n
               n -= 1
       
       c = countdown(5)
       print c.next()
       print c.next()
       print c.next()
       print c.next()
       print c.next()
       
       for i in countdown(5):
           print i,
     #+end_src
   + 从上面的例子我们可以看到, yield的结果和文件以及list一样是"可序列化的(iterable)", 也就
     是说, generator的这个特性可以让我们写出更通用的代码.
** Coroutines
   + to be continued
** Objects and Classes
   + 在python中, 每一个value都是object. 所谓object也就是包含两部分:1值2方法. 在python中,有个
     dir的函数可以列出能在某个object上面调用的所有方法
     #+begin_src python
       items = [37, 42]
       items.append(73)
       print items
       print dir(items)
     #+end_src
   + dir()的结果,除了常见的insert()和append()还有__add__()这种函数内部操作的特殊函数
   + 创建一个新的class类型,用的是关键字class,如下.在python中,我们是使用()来表示继承关系的,下面的class
     继承自object,其实所有的python object都继承自object
     #+begin_src python
       class Stack(object):
           def __init__(self ):
               self.stack = []
           def push():
               self.stack.append(object)
           def pop(self):
               return self.stack.pop()
           def length(self):
               return len(self.stack)
     #+end_src
   + 当然了,我们发现其实stack这个类型大部分都来自list这种数据类型,我们可以通过把stack继承自list来完成这次
     的类定义
     #+begin_src python 
       class Stack(list):
           # Add push () method for stack interface
           def push(self, object):
               self.append(object)
     #+end_src
   + 需要注意的是,我们所有定义的函数都是对"类的对象"起作用的,如果想让这个函数被类直接调用,那么就要创建static
     函数
     #+begin_src python
       class EventHandler(object):
           @staticmethod
           def dispatcherThread():
               while (1):
               # ...
     #+end_src
** Exceptions
   + 如果想控制错误发生时候的情况,我们可以catch exception
     #+begin_src python
       try:
           f = open("file.txt", "r")
       except IOError as e:
           print "following is the error message"
           print e
     #+end_src
   + 创建exception的方法是通过raise
     #+begin_src python
       raise RuntimeError("Computer says no")     
     #+end_src
   + 很多系统资源比如lock,file,network connection都是有竞争性的需求的.所以我们可以同一个叫做with
     的方法来在进入某段代码的时候获得资源,离开某段代码的时候释放这个资源
     #+begin_src python
       import threading
       message_lock = threading.Lock()
       # ...
       
       with message_lock:
           messages.add(newmessage)
     #+end_src
** Modules
   + python发展起来,绝不可能是一个文件到底.就像c语言可以include一样, python也可以把常用代码保持成一个
     *.py文件,然后其他文件用到的时候,有两种方法
     1) import : 这种方法还是会创建一个新的namespace,所有的函数调用都要带前缀.如果你想改前缀名,可以用
	"import as"
	#+begin_src python
          # already has file div.py
          
          import div        # New namespace div
          a, b = div.divide(2305, 29)
          
          import div as foo # New namespace foo
          a, b = foo.divide(2305, 29)
	#+end_src
     2) from import: 这种方法是把某个module的一部分或者全部function导入到当前的namespace!
	#+begin_src python
          from div import divide   # import one function
          a, b = divide(2305, 29)  # No longer need the div prefix
          
          from div import *        # import all the functions
	#+end_src
   + 当我们无论如何方式import module的时候,dir()是我们获取此module的函数列表的绝佳方式




     

   



     











