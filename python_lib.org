#+OPTIONS: ^:{}
* Chapter 1:Text
** string: Text Constants and Templates
*** Functions
    + capwords()是大写首字母, 
      #+begin_src python
        import string
        
        s = 'The quick brown fox jumped over the lazy dog.'
        
        print s
        print string.capwords(s)
        
        # Output:
        # <============================================================================
        # The quick brown fox jumped over the lazy dog.
        # The Quick Brown Fox Jumped Over The Lazy Dog.
        # ============================================================================>
      #+end_src
    + maketrans是创建能让translate()函数试用的翻译表
      #+begin_src python
        import string
        
        leet = string.maketrans('abegiloprstz', '463611092572')
        
        s = 'The quick brown fox jumped over the lazy dog'
        
        print s
        print s.translate(leet)
        
        # Output:
        # <============================================================================
        # The quick brown fox jumped over the lazy dog
        # Th3 qu1ck 620wn f0x jum93d 0v32 7h3 142y d06
        # ============================================================================>
      #+end_src
*** Templates
    + Templates是用来从某个"字典"中取得数据然后输出, 和 string自身的那种
      format print相比,最大的区别是,template是没有字符类型的概念的,不需要
      知道是%d, %s, 还是%f. 注意${var}和$var其实是一样的，子所以还要加上{}
      是因为var是子字符串的情况。
      #+begin_src python
        import string
        
        #This is a dict, .i.e, var's value is foo
        values = { 
            'var':'foo' , 
            'num':234.2 
            } 
        
        t = string.Template("""
        Variable          : $var
        Escape            : $$
        Variable in text: ${var}iable
        """)
        
        print 'TEMPLATE:', t.substitute(values)
        
        s = """
        Variable          : %(var)s
        Escape            : %%
        Variable in text  : %(var)siable
        Number is         : %(num)f
        """
        
        print 'INTERPOLATION:', s % values
        
        # Output:
        # <============================================================================
        # TEMPLATE: 
        # Variable          : foo
        # Escape            : $
        # Variable in text: fooiable
        
        # INTERPOLATION: 
        # Variable          : foo
        # Escape            : %
        # Variable in text  : fooiable
        # Number is         : 234.200000
        # ============================================================================>
      #+end_src
    + 一个常见的良好做法是使用safe_substitute来代替substitute防止出现字典中某词
      不存在的情况
      #+begin_src python
        import string
        
        values = { 'var' : 'foo'}
        
        t = string.Template("$var is here but $missing is not provided")
        
        try:
            print 'substitute() way:', t.substitute(values)
        except KeyError, err:
            print 'ERROR:', str(err)
        
        print 'safe_substitute():', t.safe_substitute(values)    
        
        # Output:
        # <============================================================================
        # substitute() way: ERROR: 'missing'
        # safe_substitute(): foo is here but $missing is not provided
        # ============================================================================>
      #+end_src
*** Advanced Templates
    + string.Template也可以通过更改delimiter和idpattern两个attributes来实现更具体的替换
      - delimiter 用来更改提示符，默认提示符是$下面的例子就给他改成了%
      - idpattern 用来限制被替换的字符,只有满足两条:第一有提示符,第二符合idpattern的要求的字符串
	才可能被替换,比如下面的%with_underscore 一来有提示符,而来符合正则表达式[a-z]+_[a-z]+的
	的要求
      #+begin_src python 
        import string
        
        template_text = '''
          Delimiter : %%
          Replaced  : %with_underscore
          Ignored   : %notunderscored
        '''
        
        d = { 'with_underscore' : 'replaced',
              'notunderscored' : 'not replaced',
              }
        
        
        class MyTemplate(string.Template):
            """
            For delimiter, the default value is $. Note that this should not be a 
            regular expression.
            For idpattern, this is the regular expression describing the pattern for non-braced
            placeholders (the braces will be added automatically as appropriate). The default
            value is the regular expression [_a-z][_a-z0-9]*. Here, we modify it to 
            '[a-z]+_[a-z]+', which means it should be a word contains a '_'
            """
            delimiter = '%'  
            idpattern = '[a-z]+_[a-z]+'
        
        t = MyTemplate(template_text)
        print 'Modified ID pattern:'
        print t.safe_substitute(d)    
        
        # Output:
        # <============================================================================
        # Modified ID pattern:
        
        #   Delimiter : %
        #   Replaced  : replaced
        #   Ignored   : %notunderscored
        # ============================================================================>
      #+end_src
    + 除了更改idpattern，我们还可以选择更改pattern attribute,idpattern属于简单的修改(无法修改加括号的情况),
      而更改pattern attribute那就很高端了,它可以更改四个属性:
      1) escaped 确定escape sequence
      2) 不加大括号的情况下的被替换字符形状
      3) 加大括号的情况下被替换字符的形状
      4) 某些特殊的情况,比如只有一个delimiter的情况
      下面,我们来看一下,默认的string.Template的pattern是什么样子的,可以通过新建一个string.Template
      来查看
      #+begin_src python
        import string
        
        # Construct a string.Template instance with a simple string argument
        t = string.Template('$var')
        print t.pattern.pattern
        
        # Output:
        # <============================================================================
            # \$(?:
            #   (?P<escaped>\$) |   # Escape sequence of two delimiters
            #   (?P<named>[_a-z][_a-z0-9]*)      |   # delimiter and a Python identifier
            #   {(?P<braced>[_a-z][_a-z0-9]*)}   |   # delimiter and a braced identifier
            #   (?P<invalid>)              # Other ill-formed delimiter exprs
            # )
        # ============================================================================>
        
      #+end_src
    + 下面看一个通过全部重写pattern attribute来进行字符串替换的例子, 可以看到这个例子中非常变态
      的把delimiter设置成了{{,这样的话,被替换字符带大括号的情况下是需要重新写的,下面例子中把它
      设置成了和不带大括号的<named>一样
      #+begin_src python 
        import re
        import string
        
        class MyTemplate(string.Template):
            delimiter = '{{'
            pattern = r'''
            \{\{(?:
            (?P<escaped>\{\{)|
            (?P<named>[_a-z][_a-z0-9]*)\}\}|
            (?P<braced>[_a-z][_a-z0-9]*)\}\}|
            (?P<invalide>)
            )
            '''
        t = MyTemplate('''
        {{{{
        {{var}}
        ''')
        
        print 'MATCHES:', t.pattern.findall(t.template)
        print 'SUBSTITUTED:', t.safe_substitute(var='replacement')
        
        # Output:
        # <============================================================================
        # MATCHES: [('{{', '', '', ''), ('', 'var', '', '')]
        # SUBSTITUTED: 
        # {{
        # replacement
        # ============================================================================>
      #+end_#+byegin_src c++ 
      #+end_src

** textwrap--Formatting Text Paragraphs
*** Example Data
*** Filling Paragraphs
    + fill()函数把文本作为输入,制作输出
      #+begin_src python
        import textwrap
        
        sample_text = '''
            The textwrap module can be used to format text for output in
            situtations where pretty-prints is desired. It offers 
            programmatic functionality similar to the paragraph wrapping
            or filling features found inmany text editors.
           '''
        
        print 'No dedent:\n'
        print textwrap.fill(sample_text, width=50)   
        
        # Output:
        # <============================================================================
        # No dedent:
        #
        #      The textwrap module can be used to format
        # text for output in     situtations where pretty-
        # prints is desired. It offers      programmatic
        # functionality similar to the paragraph wrapping
        # or filling features found inmany text editors.
        # ============================================================================>
      #+end_src
    + 效果貌似不理想,还是存在intent
*** Removing Existing Indentation
    + 去掉intent的方法:
      #+begin_src python
        import textwrap
        
        sample_text = '''
            The textwrap module can be used to format text for output in
            situtations where pretty-prints is desired. It offers 
            programmatic functionality similar to the paragraph wrapping
            or filling features found inmany text editors.
           '''
        
        
        print 'Dedent:'
        print textwrap.dedent(sample_text)
        
        # Output:
        # <============================================================================
        # Dedent:
        #
        # The textwrap module can be used to format text for output in
        # situtations where pretty-prints is desired. It offers 
        # programmatic functionality similar to the paragraph wrapping
        # or filling features found inmany text editors.
        # ============================================================================>
      #+end_src
*** Combining Dedent and Fill
    + 吧dedented的text作为参数传给fill()就完成了两者的结合
            #+begin_src python
              import textwrap
              
              sample_text = '''
                  The textwrap module can be used to format text for output in
                  situtations where pretty-prints is desired. It offers 
                  programmatic functionality similar to the paragraph wrapping
                  or filling features found inmany text editors.
                 '''
              dedented_text = textwrap.dedent(sample_text).strip()
              for width in [45, 70]:
                  print '%d Columns:\n' % width
                  print textwrap.fill(dedented_text, width=width)
              
              # Output:
              # <============================================================================
              # 45 Columns:
              #
              # The textwrap module can be used to format
              # text for output in situtations where pretty-
              # prints is desired. It offers  programmatic
              # functionality similar to the paragraph
              # wrapping or filling features found inmany
              # text editors.
              # 70 Columns:
              #
              # The textwrap module can be used to format text for output in
              # situtations where pretty-prints is desired. It offers  programmatic
              # functionality similar to the paragraph wrapping or filling features
              # found inmany text editors. 
              # ============================================================================>
      #+end_src
*** Hanging Indentsy
    + 输出的宽度可以被设置,同样的缩进大小也可以被设置
      #+begin_src python
        import textwrap
        
        sample_text = '''
            The textwrap module can be used to format text for output in
            situtations where pretty-prints is desired. It offers 
            programmatic functionality similar to the paragraph wrapping
            or filling features found inmany text editors.
           '''
        dedented_text = textwrap.dedent(sample_text).strip()
        print textwrap.fill(dedented_text,
                            initial_indent='',
                            subsequent_indent=' ' * 4,
                            width=50,
                            )
        
        # Output:
        # <============================================================================
        # The textwrap module can be used to format text for
        #     output in situtations where pretty-prints is
        #     desired. It offers  programmatic functionality
        #     similar to the paragraph wrapping or filling
        #     features found inmany text editors.
        # ============================================================================>
      #+end_src
** re--Regular Expressions
*** Finding Patterns in Text
    + re最常用的地方应该就是寻找字符串,也就是search()函数, 如果没有匹配字符串search()返回None,
      如果找到了,则返回Match object
    + Match object含有很多内容, 比如原始正则表达式是什么, 在哪里找到的,找到的字符串是什么
      #+begin_src python
        import re
        
        pattern = 'this'
        text = 'Does this text match the pattern?'
        
        match = re.search(pattern, text)
        
        s = match.start()
        e = match.end()
        
        print 'Found "%s"\n in "%s"\nfrom %d to %d ("%s")' % \
          (match.re.pattern, match.string, s, e, text[s:e])
        
        # Output:
        # <============================================================================
        # Found "this"
        #  in "Does this text match the pattern?"
        # from 5 to 9 ("this") 
        # ============================================================================>
      #+end_src
*** Compiling Expressions
    + 如果经常使用,可以把某个字符通过compile()函数来转化成RegexObject
      #+begin_src python
        import re
        
        #Precompile the patterns
        regexes = [re.compile(p)
                   for p in ['this', 'that']
                   ]
        text = 'Does this text match the pattern?'
        
        print 'Text: %r\n' % text
        
        for regex in regexes:
            print 'Seeking "%s" ->' % regex.pattern,
        
            if regex.search(text):
                print 'match!'
            else:
                print 'no match'
        
        # Output:
        # <============================================================================
        # Text: 'Does this text match the pattern?'
        #
        # Seeking "this" -> match!
        # Seeking "that" -> no match
        # ============================================================================>
      #+end_src
    + 前面的module(search函数)会维护一个cache,但是cache大小有限制,使用了compiled expression后
      我们可以直接减去查找cache的消耗
    + 另外一个好处就是complied的话,可以使得工作都集中在导入阶段,如果有用户交互的话,时间差就不会被
      用户所感觉到.
*** Multiple Matches
    + 如果有多个匹配的查找结果,我们就要依靠findall函数了. findall函数返回匹配的字符串结果
      #+begin_src python
        import re
        
        text = 'abbaaabbbbaaaaa'
        pattern = 'ab'
        
        for match in re.findall(pattern, text):
            print 'Found "%s"' % match
        
        # Output:
        # <============================================================================
        # Found "ab"
        # Found "ab"
        # ============================================================================>
      #+end_src
    + 如果想知道匹配字符串的位置可以使用finditer函数
      #+begin_src python
        import re
        
        text = 'abbaaabbbbaaaaa'
        pattern = 'ab'
        
        for match in re.finditer(pattern, text):
            s = match.start()
            e = match.end()
            print 'Found "%s" at %d:%d' % (text[s:e], s, e)
        
        # Output:
        # <============================================================================
        # Found "ab" at 0:2
        # Found "ab" at 5:7
        # ============================================================================>  
      #+end_src
*** Pattern Syntax
    + 我们还可以通过像'.'这种meta character来使得我们的查找结果更明显
      #+begin_src python
        import re 
        
        def test_patterns(text, patterns=[]):
            """Given source text and a list of patterns, look for
            matches for each pattern within the text and print
            them to stdout.
            """
            for pattern, desc in patterns:
                print 'Pattern %r (%s)\n' % (pattern, desc)
                print '  %r'  % text
                for match in re.finditer(pattern, text):
                    s = match.start()
                    e = match.end()
                    substr = text[s:e]
                    n_backslashes = text[:s].count('\\')
                    prefix = '.' * (s + n_backslashes)
                    print '  %s%r' % (prefix, substr)
                print
            return
        
        if __name__ == '__main__':
            test_patterns('abbaaabbbbaaaaa',
                          [('ab', "'a' followd by 'b'"),
                           ])
        # Output:
        # <============================================================================
        # Pattern 'ab' ('a' followd by 'b')
        #
        #   'abbaaabbbbaaaaa'
        #   'ab'
        #   .....'ab' 
        # ============================================================================>
      #+end_src
**** Repetition
     + 下面是关于正则表达式中表达"重复"的例子
        #+begin_src python
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns('abbaaabbbbaaaaa',
                           [('ab*',       'a followed by zero or more b'),
                            ('ab+',       'a followed by one or more b'),
                            ('ab?',       'a followed by zero or one b'),
                            ('ab{3}',     'a followed by three b'),
                            ('ab{2,3}',   'a followed by tow to  three b'),
                            ])
         # Output:
         # <============================================================================
         #  Pattern 'ab*' (a followed by zero or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   ...'a'
         #   ....'a'
         #   .....'abbbb'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab+' (a followed by one or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   .....'abbbb'
         # 
         # Pattern 'ab?' (a followed by zero or one b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   ...'a'
         #   ....'a'
         #   .....'ab'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab{3}' (a followed by three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   .....'abbb'
         # 
         # Pattern 'ab{2,3}' (a followed by tow to  three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   .....'abbb'
         #  Pattern 'ab*' (a followed by zero or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   ...'a'
         #   ....'a'
         #   .....'abbbb'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab+' (a followed by one or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   .....'abbbb'
         # 
         # Pattern 'ab?' (a followed by zero or one b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   ...'a'
         #   ....'a'
         #   .....'ab'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab{3}' (a followed by three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   .....'abbb'
         # 
         # Pattern 'ab{2,3}' (a followed by tow to  three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   .....'abbb'
         # ============================================================================>
       #+end_src
     + 归纳起来,重复就有如下五种方式
       1) * 表示0或者多次重复
       2) + 表示1或者多次重复
       3) ? 表示0或者1次重复
       4) {m}表示必须重复m次
       5) {m,n}表示重复最少m次,最多n次: {m,}表示最少m次,多了不限
     + 默认的正则表达式是贪婪匹配,可以通过在pattern最后加上?来关闭贪婪匹配
       #+begin_src python
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns('abbaaabbbbaaaaa',
                           [('ab*?',       'a followed by zero or more b'),
                            ('ab+?',       'a followed by one or more b'),
                            ('ab??',       'a followed by zero or one b'),
                            ('ab{3}?',     'a followed by three b'),
                            ('ab{2,3}?',   'a followed by tow to  three b'),
                            ])
         # Output:
         # <============================================================================
         # Pattern 'ab*?' (a followed by zero or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'a'
         #   ...'a'
         #   ....'a'
         #   .....'a'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab+?' (a followed by one or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   .....'ab'
         # 
         # Pattern 'ab??' (a followed by zero or one b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'a'
         #   ...'a'
         #   ....'a'
         #   .....'a'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab{3}?' (a followed by three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   .....'abbb'
         # 
         # Pattern 'ab{2,3}?' (a followed by tow to  three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   .....'abb'
         # ============================================================================>
       #+end_src
**** Character Sets
     + 所谓Character Sets就是一组的字符里面任何一个匹配成功都算成功,比如对于[ab]来说,a和b都
       算匹配成功
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns('abbaaabbbbaaaaa',
                           [('[ab]',       'either a or b'),
                            ('a[ab]+',      'a followed by 1 or more a or b'),
                            ('a[ab]+?',     'a followed by 1 or more a or b, not greedy'),
                            ])
         # Output:
         # <============================================================================
         # Pattern '[ab]' (either a or b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'a'
         #   .'b'
         #   ..'b'
         #   ...'a'
         #   ....'a'
         #   .....'a'
         #   ......'b'
         #   .......'b'
         #   ........'b'
         #   .........'b'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'a[ab]+' (a followed by 1 or more a or b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abbaaabbbbaaaaa'
         # 
         # Pattern 'a[ab]+?' (a followed by 1 or more a or b, not greedy)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   ...'aa'
         #   .....'ab'
         #   ..........'aa'
         #   ............'aa'
         # ============================================================================>
       #+end_src
     + 还可以用carat(^)加在character sets里面来排除某些字符
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns(
             'This is some text -- with punctuation.',
             [ ('[^-. ]+', 'sequences without -, ., or space'),
               ])
         
         # Output:
         # <============================================================================
         # Pattern '[^-. ]+' (sequences without -, ., or space)
         # 
         #   'This is some text -- with punctuation.'
         #   'This'
         #   .....'is'
         #   ........'some'
         #   .............'text'
         #   .....................'with'
         #   ..........................'punctuation' 
         # ============================================================================>
       #+end_src
     + 如果字符多的情况下,一个个在[]中列出来显然不是特别现实,这种情况下character range就显得
       特别有用,其使用方法就是在[]中写上ascii字符范围
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns(
             'This is some text -- with punctuation.',
             [ ('[a-z]+', 'sequences of lowercase letters'),
               ('[A-Z]+', 'sequences of uppercase letters'),
               ('[a-zA-Z]+', 'sequences of lowercase or uppercase letters'),
               ('[A-Z][a-z]+', 'one uppercase followed by lowercase'),
               ])
         
         # Output:
         # <============================================================================
         # Pattern '[a-z]+' (sequences of lowercase letters)
         # 
         #   'This is some text -- with punctuation.'
         #   .'his'
         #   .....'is'
         #   ........'some'
         #   .............'text'
         #   .....................'with'
         #   ..........................'punctuation'
         # 
         # Pattern '[A-Z]+' (sequences of uppercase letters)
         # 
         #   'This is some text -- with punctuation.'
         #   'T'
         # 
         # Pattern '[a-zA-Z]+' (sequences of lowercase or uppercase letters)
         # 
         #   'This is some text -- with punctuation.'
         #   'This'
         #   .....'is'
         #   ........'some'
         #   .............'text'
         #   .....................'with'
         #   ..........................'punctuation'
         # 
         # Pattern '[A-Z][a-z]+' (one uppercase followed by lowercase)
         # 
         #   'This is some text -- with punctuation.'
         #   'This'
         # ============================================================================>
       #+end_src
     + period(.)是非常特殊的一种character sets,在匹配里面,它可以表示任意字符,也就是说它用
       character set表示的话就是[ascii开始-ascii结束], period如果再和前面的五种重复一块
       使用,会产生非常长的结果,比如下面的'a.*b', 最后产生了一个匹配'abbaaabbbb',使用非贪婪匹
       配会好很多,比如下面的'a.*?b',得到的结果也更合理.
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns('abbaaabbbbaaaaa',
                           [('a.',         'a followed by any one character'),
                            ('b.',         'b followed by any one character'),
                            ('a.*b',      'a followed by anything, ending in b'),
                            ('a.*?b',     'a followed by anything, ending in b'),
                            ])
         
         # # Output:
         # # <============================================================================
         # Pattern 'a.' (a followed by any one character)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   ...'aa'
         #   .....'ab'
         #   ..........'aa'
         #   ............'aa'
         # 
         # Pattern 'b.' (b followed by any one character)
         # 
         #   'abbaaabbbbaaaaa'
         #   .'bb'
         #   ......'bb'
         #   ........'bb'
         # 
         # Pattern 'a.*b' (a followed by anything, ending in b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abbaaabbbb'
         # 
         # Pattern 'a.*?b' (a followed by anything, ending in b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   ...'aaab'
         # ============================================================================>
       #+end_src
**** Escape Codes
     + 更抽象的表示是转义码,如下图
       | Code | Meaning                               |
       |------+---------------------------------------|
       | \d   | A digit                               |
       | \D   | A nondigit                            |
       | \s   | Whitespace(tab, space, newline, etc.) |
       | \S   | Nonwhitespace                         |
       | \w   | Alphanumeric                          |
       | \W   | Nonalphanumeric                       |
     + 所有的转义码前面都有一"\", 但是在普通python string里面,如果要显示出"\", 需要"\\", 而且也
       更难以阅读和理解.所以我们在使用转义码的时候,不使用普通pythong string,而是使用raw string,
       也就是在文本字符串前面加个"r"
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns(
                 'A prime #1 example!',
                 [ (r'\d+', 'sequence of digits'),
                   (r'\D+', 'sequence of nondigits'),
                   (r'\s+', 'sequence of whitespace'),
                   (r'\S+', 'sequence of nonwhitespace'),
                   (r'\w+', 'alphanumeric characters'),
                   (r'\W+', 'nonalphanumeric characters'),
                   ])
         
         # Output:
         # <============================================================================
         # Pattern '\\d+' (sequence of digits)
         # 
         #   'A prime #1 example!'
         #   .........'1'
         # 
         # Pattern '\\D+' (sequence of nondigits)
         # 
         #   'A prime #1 example!'
         #   'A prime #'
         #   ..........' example!'
         # 
         # Pattern '\\s+' (sequence of whitespace)
         # 
         #   'A prime #1 example!'
         #   .' '
         #   .......' '
         #   ..........' '
         # 
         # Pattern '\\S+' (sequence of nonwhitespace)
         # 
         #   'A prime #1 example!'
         #   'A'
         #   ..'prime'
         #   ........'#1'
         #   ...........'example!'
         # 
         # Pattern '\\w+' (alphanumeric characters)
         # 
         #   'A prime #1 example!'
         #   'A'
         #   ..'prime'
         #   .........'1'
         #   ...........'example'
         # 
         # Pattern '\\W+' (nonalphanumeric characters)
         # 
         #   'A prime #1 example!'
         #   .' '
         #   .......' #'
         #   ..........' '
         #   ..................'!' 
         # ============================================================================>
       #+end_src
**** Anchoring
     + 如果需要匹配字符串出现的相对位置(字串头,字串尾), 那么就需要用到"锚定"
       | Code | Meaning                                            |
       |------+----------------------------------------------------|
       | (^)  | Start of string, or line                           |
       | ($)  | End of string, or line                             |
       | (\A) | Start of string                                    |
       | (\Z) | End of string                                      |
       | (\b) | Empty string at the beginning or end of a word     |
       | (\B) | Empty string not at the beginning or end of a word |
       
     + 下面的例子中匹配开头用了'^\w+', 按说这里的匹配结尾应该用'\w+$', 但是
       因为这个原始字符串中有句号".",它不属于任何的字母,所以我们用'\S*'来匹配.
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns(
                 'This is some text -- with punctuation.',
                 [ (r'^\w+',    'word at start of string'),
                   (r'\A\w+',   'word at start of string'),
                   (r'\w+\S*$', 'word near end of string, skip punctuation'),
                   (r'\w+\S*\Z','word near end of string, skip punctuation'),
                   (r'\w*t\w*', 'word containing t'),
                   (r'\bt\w+',  't at start of word'),
                   (r'\w+t\b',  't at end of word'),
                   (r'\Bt\B',   't, not start or end of word'),
                   ])
         
         # Output:
         # <============================================================================
         # Pattern '^\\w+' (word at start of string)
         # 
         #   'This is some text -- with punctuation.'
         #   'This'
         # 
         # Pattern '\\A\\w+' (word at start of string)
         # 
         #   'This is some text -- with punctuation.'
         #   'This'
         # 
         # Pattern '\\w+\\S*$' (word near end of string, skip punctuation)
         # 
         #   'This is some text -- with punctuation.'
         #   ..........................'punctuation.'
         # 
         # Pattern '\\w+\\S*\\Z' (word near end of string, skip punctuation)
         # 
         #   'This is some text -- with punctuation.'
         #   ..........................'punctuation.'
         # 
         # Pattern '\\w*t\\w*' (word containing t)
         # 
         #   'This is some text -- with punctuation.'
         #   .............'text'
         #   .....................'with'
         #   ..........................'punctuation'
         # 
         # Pattern '\\bt\\w+' (t at start of word)
         # 
         #   'This is some text -- with punctuation.'
         #   .............'text'
         # 
         # Pattern '\\w+t\\b' (t at end of word)
         # 
         #   'This is some text -- with punctuation.'
         #   .............'text'
         # 
         # Pattern '\\Bt\\B' (t, not start or end of word)
         # 
         #   'This is some text -- with punctuation.'
         #   .......................'t'
         #   ..............................'t'
         #   .................................'t'
         # ============================================================================>
       #+end_src
*** Constraining the Search
    + 如果搜索范围有限定,比如一定是从可以用match()来替代search()
       #+begin_src python 
         import re 
         
         text = 'This is some text -- with punctuation.'
         pattern = 'is'
         
         print 'Text    :', text
         print 'Pattern :', pattern
         
         m = re.match(pattern, text)
         print 'Match   :', m
         s = re.search(pattern, text)
         print 'Search  :', s
         
         # Output:
         # <============================================================================
         # Text    : This is some text -- with punctuation.
         # Pattern : is
         # Match   : None
         # Search  : <_sre.SRE_Match object at 0x02642138>
         # ============================================================================>
       #+end_src
    + search函数还可以接受额外的参数来确定搜索范围, 下面的例子其实就是一个效率较差版本的iterall()
      #+begin_src python
        import re
        
        text = 'This is some text -- with punctuation.'
        pattern = re.compile(r'\b\w*is\w*\b')
        
        print 'Text:', text
        print
        
        pos = 0
        while True:
            match = pattern.search(text, pos)
            if not match:
                break
            s = match.start()
            e = match.end()
            print '   %2d : %2d = "%s"' % \
              (s, e-1, text[s:e])
            # Move forward in text for the next search      
            pos = e
        
        # Output:
        # <============================================================================
        # Text: This is some text -- with punctuation.
        # 
        #     0 :  3 = "This"
        #     5 :  6 = "is" 
        # ============================================================================>
      #+end_src
*** Dissecting Matches with Groups
    + 通过括号(),可以把匹配字符分成几份,更增加匹配的扩展性
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns(
                 'abbaaabbbbaaaaa',
                 [ ('a(ab)',    'a followed by literal ab'),
                   ('a(a*b*)',  'a followed by 0-n a and 0-n b'),
                   ('a(ab)*',   'a followed by 0-n ab'),
                   ('a(ab)+',   'a followed by 1-n ab'),
                   ])
         
         # Output:
         # <============================================================================
         # Pattern 'a(ab)' (a followed by literal ab)
         # 
         #   'abbaaabbbbaaaaa'
         #   ....'aab'
         # 
         # Pattern 'a(a*b*)' (a followed by 0-n a and 0-n b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   ...'aaabbbb'
         #   ..........'aaaaa'
         # 
         # Pattern 'a(ab)*' (a followed by 0-n ab)
         # 
         #   'abbaaabbbbaaaaa'
         #   'a'
         #   ...'a'
         #   ....'aab'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'a(ab)+' (a followed by 1-n ab)
         # 
         #   'abbaaabbbbaaaaa'
         #   ....'aab'
         # ============================================================================>
       #+end_src
    + search()返回一个Match Object, 可以用这个object的函数goups()把结果合并起来, 在pattern中
      每一个()会产生一个匹配结果.比如下面例子中,只有r'(\bt\w+)\W+(\w)' 会产生两个结果
      #+begin_src python
        import re
        
        text = 'This is some text -- with punctuation.'
        
        print text
        print
        
        patterns = [
            (r'^(\w+)',           'word at start of string'),
            (r'(\w+)\S*$',        'word at end, with optional punctuation'),
        # There will be two members in the result, as there are two '()', here
            (r'(\bt\w+)\W+(\w)',  'word starting with t, another word'),
            (r'(\w+t)\b',         'word ending with t'),
            ]
        
        for pattern, desc in patterns:
            regex = re.compile(pattern)
            match = regex.search(text)
            print 'Pattern %r (%s)\n' % (pattern, desc)
            print '    ', match.groups()
            print
        
        # Output:
        # <============================================================================
        # This is some text -- with punctuation.
        # 
        # Pattern '^(\\w+)' (word at start of string)
        # 
        #      ('This',)
        # 
        # Pattern '(\\w+)\\S*$' (word at end, with optional punctuation)
        # 
        #      ('punctuation',)
        # 
        # Pattern '(\\bt\\w+)\\W+(\\w)' (word starting with t, another word)
        # 
        #      ('text', 'w')
        # 
        # Pattern '(\\w+t)\\b' (word ending with t)
        # 
        #      ('text',)
        # ============================================================================>
      #+end_src
    + 除了groups(),还可以使用group(),group(0)是全匹配的结果,group(n)是依次下来的匹配结果
      #+begin_src python
        import re
        
        text = 'This is some text == with punctuation.'
        
        print 'Input text              :', text
        
        
        #word starting with 't' then another word
        regex = re.compile(r'(\bt\w+)\W+(\w+)')
        print 'Pattern                 :', regex.pattern
        
        match = regex.search(text)
        print 'Entire match            :', match.group(0)
        print 'Word starting with "t"  :', match.group(1)
        print 'Word after "t" word     :', match.group(2)
        
        # Output:
        # <============================================================================
        # Input text              : This is some text == with punctuation.
        # Pattern                 : (\bt\w+)\W+(\w+)
        # Entire match            : text == with
        # Word starting with "t"  : text
        # Word after "t" word     : with
        # ============================================================================>
      #+end_src
    + python还对基本的分组增加了命名组功能,用name来命名group可以使得日后更改pattern变得容易
      #+begin_src python
        import re      
        
        text = 'This is some text -- with punctuation.'
        
        print text
        print
        
        for pattern in [ r'^(?P<first_word>\w+)',
                         r'(?P<last_word>\w)\S*$',
                         r'(?P<t_word>\bt\w+)\W+(?P<other_word>\w+)',
                         r'(?P<ends_with_t>\w+t)\b',
                         ]:
            regex = re.compile(pattern)
            match = regex.search(text)
            print 'Matching "%s"' % pattern
            print '   ', match.groups()
            print '   ', match.groupdict()
            print 
        
        # Output:
        # <============================================================================
        # This is some text -- with punctuation.
        # 
        # Matching "^(?P<first_word>\w+)"
        #     ('This',)
        #     {'first_word': 'This'}
        # 
        # Matching "(?P<last_word>\w)\S*$"
        #     ('p',)
        #     {'last_word': 'p'}
        # 
        # Matching "(?P<t_word>\bt\w+)\W+(?P<other_word>\w+)"
        #     ('text', 'with')
        #     {'other_word': 'with', 't_word': 'text'}
        # 
        # Matching "(?P<ends_with_t>\w+t)\b"
        #     ('text',)
        #     {'ends_with_t': 'text'} 
        # ============================================================================>
      #+end_src
    + 我们来用刚才学过的知识来更新test_pattern如下, 这个例子能够更好的理解groups
      - 我们说了一个()就是一个group,那么下面的r'a((a*)(b*))'就是包含了三个group
      - match.groups()的结果,表明,最外面的()是groups的第一个值,然后是(a*), (b*)
      - 由于(a*)和(b*)都有可能是空字符串,所以''也有出现
      #+begin_src python
        import re
        
        def test_patterns(text, patterns=[]):
            """ Given source text and a list of patterns, look fo
            matches for each pattern within the text and print 
            them to stdout.
            """
            # Look for each pattern in the text and print the results
            for pattern, desc in patterns:
                print 'Pattern %r (%s) \n' % (pattern, desc)
                print '   %r' % text
                for match in re.finditer(pattern, text):
                    s = match.start()
                    e = match.end()
                    prefix = ' ' * (s)
                    print '   %s%r%s ' % (prefix, text[s:e], ' '*(len(text)-e)),
                    print match.groups()
                    if match.groupdict():
                        print '%s%s' % (' ' * (len(text)-s), match.groupdict())
                print
            return
        
        test_patterns(
            'abbaabbba',
            [ (r'a((a*)(b*))', 'a followed by 0-n a and 0-n b'),
              ])
        
        # Output:
        # <============================================================================
        # Pattern 'a((a*)(b*))' (a followed by 0-n a and 0-n b) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb', '', 'bb')
        #       'aabbb'   ('abbb', 'a', 'bbb')
        #            'a'  ('', '', '')
        # ============================================================================>
      #+end_src
    + group还可以和或(|)联合起来使用,表示其中有个能够匹配即可.注意(|)位置的不同,会造成截然不同
      的结果,下面例子中的((a|b)+)和((a+)|(b+))就不相同,前者表示只要是ab相连即可,后者要求要么
      全是a,要么全是b(如果你注意观察会发现,前者是两个group,而后者是三个group
    + 这个例子中的group匹配因为有或(|)的参与,所以会出现某些子group根本不匹配的情况,python会
      选择输出None表示
      #+begin_src python
        import re
        
        def test_patterns(text, patterns=[]):
            """ Given source text and a list of patterns, look fo
            matches for each pattern within the text and print 
            them to stdout.
            """
            # Look for each pattern in the text and print the results
            for pattern, desc in patterns:
                print 'Pattern %r (%s) \n' % (pattern, desc)
                print '   %r' % text
                for match in re.finditer(pattern, text):
                    s = match.start()
                    e = match.end()
                    prefix = ' ' * (s)
                    print '   %s%r%s ' % (prefix, text[s:e], ' '*(len(text)-e)),
                    print match.groups()
                    if match.groupdict():
                        print '%s%s' % (' ' * (len(text)-s), match.groupdict())
                print
            return
        
        test_patterns(
            'abbaabbba',
            [ (r'a((a+)|(b+))', 'a then seq. of a or seq. of b'),
              (r'a((a|b)+)',  'a then seq. of [ab]'),
              ])
        
        # Output:
        # <============================================================================
        # Pattern 'a((a+)|(b+))' (a then seq. of a or seq. of b) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb', None, 'bb')
        #       'aa'      ('a', 'a', None)
        # 
        # Pattern 'a((a|b)+)' (a then seq. of [ab]) 
        # 
        #    'abbaabbba'
        #    'abbaabbba'  ('bbaabbba', 'a')
        # ============================================================================>
      #+end_src
    + 如果我们对某些子group产生的结果不感兴趣,我们可以用?:来把这些子group标记为noncapturing的
      这样在match object groups函数里面就不会有这些部分的痕迹了.
      #+begin_src python
        import re
        
        def test_patterns(text, patterns=[]):
            """ Given source text and a list of patterns, look fo
            matches for each pattern within the text and print 
            them to stdout.
            """
            # Look for each pattern in the text and print the results
            for pattern, desc in patterns:
                print 'Pattern %r (%s) \n' % (pattern, desc)
                print '   %r' % text
                for match in re.finditer(pattern, text):
                    s = match.start()
                    e = match.end()
                    prefix = ' ' * (s)
                    print '   %s%r%s ' % (prefix, text[s:e], ' '*(len(text)-e)),
                    print match.groups()
                    if match.groupdict():
                        print '%s%s' % (' ' * (len(text)-s), match.groupdict())
                print
            return
        
        test_patterns(
            'abbaabbba',
            [ (r'a((a+)|(b+))',     'capturing form'),
              (r'a((a+)|(?:b+))',   'noncapturing form, do not care about a'),
              (r'a((?:a+)|(b+))',   'noncapturing form, do not care about b'),
              (r'a((?:a+)|(?:b+))', 'noncapturing form, do not care about a or b'),
              ])
        
        # Output:
        # <============================================================================
        # Pattern 'a((a+)|(b+))' (capturing form) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb', None, 'bb')
        #       'aa'      ('a', 'a', None)
        # 
        # Pattern 'a((a+)|(?:b+))' (noncapturing form, do not care about a) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb', None)
        #       'aa'      ('a', 'a')
        # 
        # Pattern 'a((?:a+)|(b+))' (noncapturing form, do not care about b) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb', 'bb')
        #       'aa'      ('a', None)
        # 
        # Pattern 'a((?:a+)|(?:b+))' (noncapturing form, do not care about a or b) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb',)
        #       'aa'      ('a',)
        # ============================================================================>
      #+end_src
*** Search Options
    + 搜索的时候可以选择很多的选项,比如是否大小写敏感.等等. 
**** Case-Insensitive Matching
     + 搜索的时候用IGNORECASE变量来设置不敏感
       #+begin_src python
         import re
         
         text = 'This is some text -- with punctuation.'
         pattern = r'\bT\w+'
         with_case = re.compile(pattern)
         without_case = re.compile(pattern, re.IGNORECASE)
         
         print 'Text:\n  %r'  % text
         print 'Pattern:\n %s' % pattern
         print 'Case-sensitive:'
         for match in with_case.findall(text):
             print '   %r' % match
         print 'Case-insensitive:'
         for match in without_case.findall(text):
             print '   %r' % match
         
         # Output:
         # <============================================================================
         # Text:
         #   'This is some text -- with punctuation.'
         # Pattern:
         #  \bT\w+
         # Case-sensitive:
         #    'This'
         # Case-insensitive:
         #    'This'
         #    'text'
         # ============================================================================>
       #+end_src
     + MULTILINE变量可以设置成把带换行符(\n)的字符串当做是多行字符串,在每行字符串都匹配开头和结尾
       两个锚定规则(^和$)
       #+begin_src python
         import re
         
         text = 'This is some text -- with punctuation.\nA second line.'
         pattern = r'(^\w+)|(\w+\S*$)'
         single_line = re.compile(pattern)
         multiline = re.compile(pattern, re.MULTILINE)
         
         print 'Text:\n   %r' % text
         print 'Pattern: \n %s' % pattern
         print 'Single Line :'
         for match in single_line.findall(text):
             print '   %r' % (match,)
         print 'Multiline   :'
         for match in multiline.findall(text):
             print '   %r' % (match,)
         
         # Output:
         # <============================================================================
         # Text:
         #    'This is some text -- with punctuation.\nA second line.'
         # Pattern: 
         #  (^\w+)|(\w+\S*$)
         # Single Line :
         #    ('This', '')
         #    ('', 'line.')
         # Multiline   :
         #    ('This', '')
         #    ('', 'punctuation.')
         #    ('A', '')
         #    ('', 'line.')
         # ============================================================================>
       #+end_src
     + 一般情况下,dot character(.)是可以匹配除了换行符以外的任意的字符, 而加了DOTALL以后, dot 
       character就同时可以匹配换行符了.
       #+begin_src python
         import re
         
         text = 'This is some text -- with punctuation.\nA second line.'
         pattern = r'.+'
         no_newlines = re.compile(pattern)
         dotall = re.compile(pattern, re.DOTALL)
         
         print 'Text:\n %r' % text
         print 'Pattern:\n %s' % pattern
         print 'No newlines :'
         for match in no_newlines.findall(text):
             print '   %r' % match
         print 'Dotall      :'
         for match in dotall.findall(text):
             print '   %r' % match
         
         # Output:
         # <============================================================================
         # Text:
         #  'This is some text -- with punctuation.\nA second line.'
         # Pattern:
         #  .+
         # No newlines :
         #    'This is some text -- with punctuation.'
         #    'A second line.'
         # Dotall      :
         #    'This is some text -- with punctuation.\nA second line.' 
         # ============================================================================>
       #+end_src
**** Unicode
     + 对于python 2来说, 所有的字符串都默认是ASCII,所以\w+能够匹配"French", 但是却无法匹配法语
       'Français', 所以我们需要UNICODE flag.
     + python 3默认都使用unicode,所以这个flag在python3中是没有用了
       #+begin_src python
         # -*- coding:utf-8 -*-
         import re
         import codecs
         import sys
         
         # Set standard output encoding to UTF-8
         sys.stdout = codecs.getwriter('UTF-8')(sys.stdout)
         
         text = u'Français zloty Österreich'
         pattern = ur'\w+'
         ascii_pattern = re.compile(pattern)
         unicode_pattern = re.compile(pattern, re.UNICODE)
         
         print 'Text    :', text
         print 'Pattern :', pattern
         print 'ASCII   :', u', '.join(ascii_pattern.findall(text))
         print 'Unicode :', u', '.join(unicode_pattern.findall(text))
         
         # Output:
         # <============================================================================
         # Text    : Français zloty Österreich
         # Pattern : \w+
         # ASCII   : Fran, ais, zloty, sterreich
         # Unicode : Français zloty Österreich
         # ============================================================================>
       #+end_src
**** Verbose Expression Syntax
     + 下面是一个检测邮箱地址是否合法的程序,我们发现这个正则表达式实在是太长了,也不好理解
       #+begin_src python 
         import re
         
         address = re.compile('[\w\d.+-]+@([\w\d.]+\.)+(com|org|edu)',
                              re.UNICODE)
         
         candidates = [
             u'first.last@example.com',
             u'first.last+category@gmail.com',
             u'valid-address@mail.example.com',
             u'not-valid@example.foo',
             ]
         
         for candidate in candidates:
             match = address.search(candidate)
             print '%-30s %s' % (candidate, 'Matches' if match else 'NO match')
         
         # Output:
         # <============================================================================
         # first.last@example.com         Matches
         # first.last+category@gmail.com  Matches
         # valid-address@mail.example.com Matches
         # not-valid@example.foo          NO match 
         # ============================================================================>
       #+end_src
     + 所以我们要用到另外一个flag VERBOSE,能够把表达式描写的更易于阅读一点
       #+begin_src python
         import re
         
         address = re.compile(
             '''
             [\w\d.+-]+         # username
             @  
             ([\w\d.]+\.)+      # domain name prefix
             (com|org|edu)      # TODO: suppor tomore top-level domains
             ''',
             re.UNICODE | re.VERBOSE)
         
         candidates = [
             u'first.last@example.com',
             u'first.last+category@gmail.com',
             u'valid-address@mail.example.com',
             u'not-valid@example.foo',
             ]
         
         for candidate in candidates:
             match = address.search(candidate)
             print '%-30s %s' % (candidate, 'Matches' if match else 'NO match')
         
         # Output:
         # <============================================================================
         # first.last@example.com         Matches
         # first.last+category@gmail.com  Matches
         # valid-address@mail.example.com Matches
         # not-valid@example.foo          NO match 
         # ============================================================================>
       #+end_src










      
       
       
      
       
      
      
      
       
