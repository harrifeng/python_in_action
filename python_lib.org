#+OPTIONS: ^:{}
* Chapter 1:Text
** string: Text Constants and Templates
*** Functions
    + capwords()是大写首字母, 
      #+begin_src python
        import string
        
        s = 'The quick brown fox jumped over the lazy dog.'
        
        print s
        print string.capwords(s)
        
        # Output:
        # <============================================================================
        # The quick brown fox jumped over the lazy dog.
        # The Quick Brown Fox Jumped Over The Lazy Dog.
        # ============================================================================>
      #+end_src
    + maketrans是创建能让translate()函数试用的翻译表
      #+begin_src python
        import string
        
        leet = string.maketrans('abegiloprstz', '463611092572')
        
        s = 'The quick brown fox jumped over the lazy dog'
        
        print s
        print s.translate(leet)
        
        # Output:
        # <============================================================================
        # The quick brown fox jumped over the lazy dog
        # Th3 qu1ck 620wn f0x jum93d 0v32 7h3 142y d06
        # ============================================================================>
      #+end_src
*** Templates
    + Templates是用来从某个"字典"中取得数据然后输出, 和 string自身的那种
      format print相比,最大的区别是,template是没有字符类型的概念的,不需要
      知道是%d, %s, 还是%f. 注意${var}和$var其实是一样的，子所以还要加上{}
      是因为var是子字符串的情况。
      #+begin_src python
        import string
        
        #This is a dict, .i.e, var's value is foo
        values = { 
            'var':'foo' , 
            'num':234.2 
            } 
        
        t = string.Template("""
        Variable          : $var
        Escape            : $$
        Variable in text: ${var}iable
        """)
        
        print 'TEMPLATE:', t.substitute(values)
        
        s = """
        Variable          : %(var)s
        Escape            : %%
        Variable in text  : %(var)siable
        Number is         : %(num)f
        """
        
        print 'INTERPOLATION:', s % values
        
        # Output:
        # <============================================================================
        # TEMPLATE: 
        # Variable          : foo
        # Escape            : $
        # Variable in text: fooiable
        
        # INTERPOLATION: 
        # Variable          : foo
        # Escape            : %
        # Variable in text  : fooiable
        # Number is         : 234.200000
        # ============================================================================>
      #+end_src
    + 一个常见的良好做法是使用safe_substitute来代替substitute防止出现字典中某词
      不存在的情况
      #+begin_src python
        import string
        
        values = { 'var' : 'foo'}
        
        t = string.Template("$var is here but $missing is not provided")
        
        try:
            print 'substitute() way:', t.substitute(values)
        except KeyError, err:
            print 'ERROR:', str(err)
        
        print 'safe_substitute():', t.safe_substitute(values)    
        
        # Output:
        # <============================================================================
        # substitute() way: ERROR: 'missing'
        # safe_substitute(): foo is here but $missing is not provided
        # ============================================================================>
      #+end_src
*** Advanced Templates
    + string.Template也可以通过更改delimiter和idpattern两个attributes来实现更具体的替换
      - delimiter 用来更改提示符，默认提示符是$下面的例子就给他改成了%
      - idpattern 用来限制被替换的字符,只有满足两条:第一有提示符,第二符合idpattern的要求的字符串
	才可能被替换,比如下面的%with_underscore 一来有提示符,而来符合正则表达式[a-z]+_[a-z]+的
	的要求
      #+begin_src python 
        import string
        
        template_text = '''
          Delimiter : %%
          Replaced  : %with_underscore
          Ignored   : %notunderscored
        '''
        
        d = { 'with_underscore' : 'replaced',
              'notunderscored' : 'not replaced',
              }
        
        
        class MyTemplate(string.Template):
            """
            For delimiter, the default value is $. Note that this should not be a 
            regular expression.
            For idpattern, this is the regular expression describing the pattern for non-braced
            placeholders (the braces will be added automatically as appropriate). The default
            value is the regular expression [_a-z][_a-z0-9]*. Here, we modify it to 
            '[a-z]+_[a-z]+', which means it should be a word contains a '_'
            """
            delimiter = '%'  
            idpattern = '[a-z]+_[a-z]+'
        
        t = MyTemplate(template_text)
        print 'Modified ID pattern:'
        print t.safe_substitute(d)    
        
        # Output:
        # <============================================================================
        # Modified ID pattern:
        
        #   Delimiter : %
        #   Replaced  : replaced
        #   Ignored   : %notunderscored
        # ============================================================================>
      #+end_src
    + 除了更改idpattern，我们还可以选择更改pattern attribute,idpattern属于简单的修改(无法修改加括号的情况),
      而更改pattern attribute那就很高端了,它可以更改四个属性:
      1) escaped 确定escape sequence
      2) 不加大括号的情况下的被替换字符形状
      3) 加大括号的情况下被替换字符的形状
      4) 某些特殊的情况,比如只有一个delimiter的情况
      下面,我们来看一下,默认的string.Template的pattern是什么样子的,可以通过新建一个string.Template
      来查看
      #+begin_src python
        import string
        
        # Construct a string.Template instance with a simple string argument
        t = string.Template('$var')
        print t.pattern.pattern
        
        # Output:
        # <============================================================================
            # \$(?:
            #   (?P<escaped>\$) |   # Escape sequence of two delimiters
            #   (?P<named>[_a-z][_a-z0-9]*)      |   # delimiter and a Python identifier
            #   {(?P<braced>[_a-z][_a-z0-9]*)}   |   # delimiter and a braced identifier
            #   (?P<invalid>)              # Other ill-formed delimiter exprs
            # )
        # ============================================================================>
        
      #+end_src
    + 下面看一个通过全部重写pattern attribute来进行字符串替换的例子, 可以看到这个例子中非常变态
      的把delimiter设置成了{{,这样的话,被替换字符带大括号的情况下是需要重新写的,下面例子中把它
      设置成了和不带大括号的<named>一样
      #+begin_src python 
        import re
        import string
        
        class MyTemplate(string.Template):
            delimiter = '{{'
            pattern = r'''
            \{\{(?:
            (?P<escaped>\{\{)|
            (?P<named>[_a-z][_a-z0-9]*)\}\}|
            (?P<braced>[_a-z][_a-z0-9]*)\}\}|
            (?P<invalide>)
            )
            '''
        t = MyTemplate('''
        {{{{
        {{var}}
        ''')
        
        print 'MATCHES:', t.pattern.findall(t.template)
        print 'SUBSTITUTED:', t.safe_substitute(var='replacement')
        
        # Output:
        # <============================================================================
        # MATCHES: [('{{', '', '', ''), ('', 'var', '', '')]
        # SUBSTITUTED: 
        # {{
        # replacement
        # ============================================================================>
      #+end_src
** textwrap--Formatting Text Paragraphs
*** Example Data
*** Filling Paragraphs
    + fill()函数把文本作为输入,制作输出
      #+begin_src python
        import textwrap
        
        sample_text = '''
            The textwrap module can be used to format text for output in
            situtations where pretty-prints is desired. It offers 
            programmatic functionality similar to the paragraph wrapping
            or filling features found inmany text editors.
           '''
        
        print 'No dedent:\n'
        print textwrap.fill(sample_text, width=50)   
        
        # Output:
        # <============================================================================
        # No dedent:
        #
        #      The textwrap module can be used to format
        # text for output in     situtations where pretty-
        # prints is desired. It offers      programmatic
        # functionality similar to the paragraph wrapping
        # or filling features found inmany text editors.
        # ============================================================================>
      #+end_src
    + 效果貌似不理想,还是存在intent
*** Removing Existing Indentation
    + 去掉intent的方法:
      #+begin_src python
        import textwrap
        
        sample_text = '''
            The textwrap module can be used to format text for output in
            situtations where pretty-prints is desired. It offers 
            programmatic functionality similar to the paragraph wrapping
            or filling features found inmany text editors.
           '''
        
        
        print 'Dedent:'
        print textwrap.dedent(sample_text)
        
        # Output:
        # <============================================================================
        # Dedent:
        #
        # The textwrap module can be used to format text for output in
        # situtations where pretty-prints is desired. It offers 
        # programmatic functionality similar to the paragraph wrapping
        # or filling features found inmany text editors.
        # ============================================================================>
      #+end_src
*** Combining Dedent and Fill
    + 吧dedented的text作为参数传给fill()就完成了两者的结合
            #+begin_src python
              import textwrap
              
              sample_text = '''
                  The textwrap module can be used to format text for output in
                  situtations where pretty-prints is desired. It offers 
                  programmatic functionality similar to the paragraph wrapping
                  or filling features found inmany text editors.
                 '''
              dedented_text = textwrap.dedent(sample_text).strip()
              for width in [45, 70]:
                  print '%d Columns:\n' % width
                  print textwrap.fill(dedented_text, width=width)
              
              # Output:
              # <============================================================================
              # 45 Columns:
              #
              # The textwrap module can be used to format
              # text for output in situtations where pretty-
              # prints is desired. It offers  programmatic
              # functionality similar to the paragraph
              # wrapping or filling features found inmany
              # text editors.
              # 70 Columns:
              #
              # The textwrap module can be used to format text for output in
              # situtations where pretty-prints is desired. It offers  programmatic
              # functionality similar to the paragraph wrapping or filling features
              # found inmany text editors. 
              # ============================================================================>
      #+end_src
*** Hanging Indentsy
    + 输出的宽度可以被设置,同样的缩进大小也可以被设置
      #+begin_src python
        import textwrap
        
        sample_text = '''
            The textwrap module can be used to format text for output in
            situtations where pretty-prints is desired. It offers 
            programmatic functionality similar to the paragraph wrapping
            or filling features found inmany text editors.
           '''
        dedented_text = textwrap.dedent(sample_text).strip()
        print textwrap.fill(dedented_text,
                            initial_indent='',
                            subsequent_indent=' ' * 4,
                            width=50,
                            )
        
        # Output:
        # <============================================================================
        # The textwrap module can be used to format text for
        #     output in situtations where pretty-prints is
        #     desired. It offers  programmatic functionality
        #     similar to the paragraph wrapping or filling
        #     features found inmany text editors.
        # ============================================================================>
      #+end_src
** re--Regular Expressions
*** Finding Patterns in Text
    + re最常用的地方应该就是寻找字符串,也就是search()函数, 如果没有匹配字符串search()返回None,
      如果找到了,则返回Match object
    + Match object含有很多内容, 比如原始正则表达式是什么, 在哪里找到的,找到的字符串是什么
      #+begin_src python
        import re
        
        pattern = 'this'
        text = 'Does this text match the pattern?'
        
        match = re.search(pattern, text)
        
        s = match.start()
        e = match.end()
        
        print 'Found "%s"\n in "%s"\nfrom %d to %d ("%s")' % \
          (match.re.pattern, match.string, s, e, text[s:e])
        
        # Output:
        # <============================================================================
        # Found "this"
        #  in "Does this text match the pattern?"
        # from 5 to 9 ("this") 
        # ============================================================================>
      #+end_src
*** Compiling Expressions
    + 如果经常使用,可以把某个字符通过compile()函数来转化成RegexObject
      #+begin_src python
        import re
        
        #Precompile the patterns
        regexes = [re.compile(p)
                   for p in ['this', 'that']
                   ]
        text = 'Does this text match the pattern?'
        
        print 'Text: %r\n' % text
        
        for regex in regexes:
            print 'Seeking "%s" ->' % regex.pattern,
        
            if regex.search(text):
                print 'match!'
            else:
                print 'no match'
        
        # Output:
        # <============================================================================
        # Text: 'Does this text match the pattern?'
        #
        # Seeking "this" -> match!
        # Seeking "that" -> no match
        # ============================================================================>
      #+end_src
    + 前面的module(search函数)会维护一个cache,但是cache大小有限制,使用了compiled expression后
      我们可以直接减去查找cache的消耗
    + 另外一个好处就是complied的话,可以使得工作都集中在导入阶段,如果有用户交互的话,时间差就不会被
      用户所感觉到.
*** Multiple Matches
    + 如果有多个匹配的查找结果,我们就要依靠findall函数了. findall函数返回匹配的字符串结果
      #+begin_src python
        import re
        
        text = 'abbaaabbbbaaaaa'
        pattern = 'ab'
        
        for match in re.findall(pattern, text):
            print 'Found "%s"' % match
        
        # Output:
        # <============================================================================
        # Found "ab"
        # Found "ab"
        # ============================================================================>
      #+end_src
    + 如果想知道匹配字符串的位置可以使用finditer函数
      #+begin_src python
        import re
        
        text = 'abbaaabbbbaaaaa'
        pattern = 'ab'
        
        for match in re.finditer(pattern, text):
            s = match.start()
            e = match.end()
            print 'Found "%s" at %d:%d' % (text[s:e], s, e)
        
        # Output:
        # <============================================================================
        # Found "ab" at 0:2
        # Found "ab" at 5:7
        # ============================================================================>  
      #+end_src
*** Pattern Syntax
    + 我们还可以通过像'.'这种meta character来使得我们的查找结果更明显
      #+begin_src python
        import re 
        
        def test_patterns(text, patterns=[]):
            """Given source text and a list of patterns, look for
            matches for each pattern within the text and print
            them to stdout.
            """
            for pattern, desc in patterns:
                print 'Pattern %r (%s)\n' % (pattern, desc)
                print '  %r'  % text
                for match in re.finditer(pattern, text):
                    s = match.start()
                    e = match.end()
                    substr = text[s:e]
                    n_backslashes = text[:s].count('\\')
                    prefix = '.' * (s + n_backslashes)
                    print '  %s%r' % (prefix, substr)
                print
            return
        
        if __name__ == '__main__':
            test_patterns('abbaaabbbbaaaaa',
                          [('ab', "'a' followd by 'b'"),
                           ])
        # Output:
        # <============================================================================
        # Pattern 'ab' ('a' followd by 'b')
        #
        #   'abbaaabbbbaaaaa'
        #   'ab'
        #   .....'ab' 
        # ============================================================================>
      #+end_src
    + 下面是关于正则表达式中表达"重复"的方式,有如下五种:
      1) * 表示0或者多次重复
      2) + 表示1或者多次重复
      3) ? 表示0或者1次重复
      4) {m}表示必须重复m次
      5) {m,n}表示重复最少m次,最多n次: {m,}表示最少m次,多了不限
      #+begin_src python
        import re 
        
        def test_patterns(text, patterns=[]):
            """Given source text and a list of patterns, look for
            matches for each pattern within the text and print
            them to stdout.
            """
            for pattern, desc in patterns:
                print 'Pattern %r (%s)\n' % (pattern, desc)
                print '  %r'  % text
                for match in re.finditer(pattern, text):
                    s = match.start()
                    e = match.end()
                    substr = text[s:e]
                    n_backslashes = text[:s].count('\\')
                    prefix = '.' * (s + n_backslashes)
                    print '  %s%r' % (prefix, substr)
                print
            return
        
        if __name__ == '__main__':
            test_patterns('abbaaabbbbaaaaa',
                          [('ab*',       'a followed by zero or more b'),
                           ('ab+',       'a followed by one or more b'),
                           ('ab?',       'a followed by zero or one b'),
                           ('ab{3}',     'a followed by three b'),
                           ('ab{2,3}',   'a followed by tow to  three b'),
                           ])
        # Output:
        # <============================================================================
        #  Pattern 'ab*' (a followed by zero or more b)
        # 
        #   'abbaaabbbbaaaaa'
        #   'abb'
        #   ...'a'
        #   ....'a'
        #   .....'abbbb'
        #   ..........'a'
        #   ...........'a'
        #   ............'a'
        #   .............'a'
        #   ..............'a'
        # 
        # Pattern 'ab+' (a followed by one or more b)
        # 
        #   'abbaaabbbbaaaaa'
        #   'abb'
        #   .....'abbbb'
        # 
        # Pattern 'ab?' (a followed by zero or one b)
        # 
        #   'abbaaabbbbaaaaa'
        #   'ab'
        #   ...'a'
        #   ....'a'
        #   .....'ab'
        #   ..........'a'
        #   ...........'a'
        #   ............'a'
        #   .............'a'
        #   ..............'a'
        # 
        # Pattern 'ab{3}' (a followed by three b)
        # 
        #   'abbaaabbbbaaaaa'
        #   .....'abbb'
        # 
        # Pattern 'ab{2,3}' (a followed by tow to  three b)
        # 
        #   'abbaaabbbbaaaaa'
        #   'abb'
        #   .....'abbb'
        #  Pattern 'ab*' (a followed by zero or more b)
        # 
        #   'abbaaabbbbaaaaa'
        #   'abb'
        #   ...'a'
        #   ....'a'
        #   .....'abbbb'
        #   ..........'a'
        #   ...........'a'
        #   ............'a'
        #   .............'a'
        #   ..............'a'
        # 
        # Pattern 'ab+' (a followed by one or more b)
        # 
        #   'abbaaabbbbaaaaa'
        #   'abb'
        #   .....'abbbb'
        # 
        # Pattern 'ab?' (a followed by zero or one b)
        # 
        #   'abbaaabbbbaaaaa'
        #   'ab'
        # ...'a'
        #   ....'a'
        #   .....'ab'
        #   ..........'a'
        #   ...........'a'
        #   ............'a'
        #   .............'a'
        #   ..............'a'
        # 
        # Pattern 'ab{3}' (a followed by three b)
        # 
        #   'abbaaabbbbaaaaa'
        #   .....'abbb'
        # 
        # Pattern 'ab{2,3}' (a followed by tow to  three b)
        # 
        #   'abbaaabbbbaaaaa'
        #   'abb'
        #   .....'abbb'
        # ============================================================================>
      #+end_src



      
