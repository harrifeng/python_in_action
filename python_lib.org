#+OPTIONS: ^:{}
* Chapter 1:Text
** string: Text Constants and Templates
*** Functions
    + capwords()是大写首字母, 
      #+begin_src python
        import string
        
        s = 'The quick brown fox jumped over the lazy dog.'
        
        print s
        print string.capwords(s)
        
        # Output:
        # <============================================================================
        # The quick brown fox jumped over the lazy dog.
        # The Quick Brown Fox Jumped Over The Lazy Dog.
        # ============================================================================>
      #+end_src
    + maketrans是创建能让translate()函数试用的翻译表
      #+begin_src python
        import string
        
        leet = string.maketrans('abegiloprstz', '463611092572')
        
        s = 'The quick brown fox jumped over the lazy dog'
        
        print s
        print s.translate(leet)
        
        # Output:
        # <============================================================================
        # The quick brown fox jumped over the lazy dog
        # Th3 qu1ck 620wn f0x jum93d 0v32 7h3 142y d06
        # ============================================================================>
      #+end_src
*** Templates
    + Templates是用来从某个"字典"中取得数据然后输出, 和 string自身的那种
      format print相比,最大的区别是,template是没有字符类型的概念的,不需要
      知道是%d, %s, 还是%f. 注意${var}和$var其实是一样的，子所以还要加上{}
      是因为var是子字符串的情况。
      #+begin_src python
        import string
        
        #This is a dict, .i.e, var's value is foo
        values = { 
            'var':'foo' , 
            'num':234.2 
            } 
        
        t = string.Template("""
        Variable          : $var
        Escape            : $$
        Variable in text: ${var}iable
        """)
        
        print 'TEMPLATE:', t.substitute(values)
        
        s = """
        Variable          : %(var)s
        Escape            : %%
        Variable in text  : %(var)siable
        Number is         : %(num)f
        """
        
        print 'INTERPOLATION:', s % values
        
        # Output:
        # <============================================================================
        # TEMPLATE: 
        # Variable          : foo
        # Escape            : $
        # Variable in text: fooiable
        
        # INTERPOLATION: 
        # Variable          : foo
        # Escape            : %
        # Variable in text  : fooiable
        # Number is         : 234.200000
        # ============================================================================>
      #+end_src
    + 一个常见的良好做法是使用safe_substitute来代替substitute防止出现字典中某词
      不存在的情况
      #+begin_src python
        import string
        
        values = { 'var' : 'foo'}
        
        t = string.Template("$var is here but $missing is not provided")
        
        try:
            print 'substitute() way:', t.substitute(values)
        except KeyError, err:
            print 'ERROR:', str(err)
        
        print 'safe_substitute():', t.safe_substitute(values)    
        
        # Output:
        # <============================================================================
        # substitute() way: ERROR: 'missing'
        # safe_substitute(): foo is here but $missing is not provided
        # ============================================================================>
      #+end_src
*** Advanced Templates
    + string.Template也可以通过更改delimiter和idpattern两个attributes来实现更具体的替换
      - delimiter 用来更改提示符，默认提示符是$下面的例子就给他改成了%
      - idpattern 用来限制被替换的字符,只有满足两条:第一有提示符,第二符合idpattern的要求的字符串
	才可能被替换,比如下面的%with_underscore 一来有提示符,而来符合正则表达式[a-z]+_[a-z]+的
	的要求
      #+begin_src python 
        import string
        
        template_text = '''
          Delimiter : %%
          Replaced  : %with_underscore
          Ignored   : %notunderscored
        '''
        
        d = { 'with_underscore' : 'replaced',
              'notunderscored' : 'not replaced',
              }
        
        
        class MyTemplate(string.Template):
            """
            For delimiter, the default value is $. Note that this should not be a 
            regular expression.
            For idpattern, this is the regular expression describing the pattern for non-braced
            placeholders (the braces will be added automatically as appropriate). The default
            value is the regular expression [_a-z][_a-z0-9]*. Here, we modify it to 
            '[a-z]+_[a-z]+', which means it should be a word contains a '_'
            """
            delimiter = '%'  
            idpattern = '[a-z]+_[a-z]+'
        
        t = MyTemplate(template_text)
        print 'Modified ID pattern:'
        print t.safe_substitute(d)    
        
        # Output:
        # <============================================================================
        # Modified ID pattern:
        
        #   Delimiter : %
        #   Replaced  : replaced
        #   Ignored   : %notunderscored
        # ============================================================================>
      #+end_src
    + 除了更改idpattern，我们还可以选择更改pattern attribute,idpattern属于简单的修改(无法修改加括号的情况),
      而更改pattern attribute那就很高端了,它可以更改四个属性:
      1) escaped 确定escape sequence
      2) 不加大括号的情况下的被替换字符形状
      3) 加大括号的情况下被替换字符的形状
      4) 某些特殊的情况,比如只有一个delimiter的情况
      下面,我们来看一下,默认的string.Template的pattern是什么样子的,可以通过新建一个string.Template
      来查看
      #+begin_src python
        import string
        
        # Construct a string.Template instance with a simple string argument
        t = string.Template('$var')
        print t.pattern.pattern
        
        # Output:
        # <============================================================================
            # \$(?:
            #   (?P<escaped>\$) |   # Escape sequence of two delimiters
            #   (?P<named>[_a-z][_a-z0-9]*)      |   # delimiter and a Python identifier
            #   {(?P<braced>[_a-z][_a-z0-9]*)}   |   # delimiter and a braced identifier
            #   (?P<invalid>)              # Other ill-formed delimiter exprs
            # )
        # ============================================================================>
        
      #+end_src
    + 下面看一个通过全部重写pattern attribute来进行字符串替换的例子, 可以看到这个例子中非常变态
      的把delimiter设置成了{{,这样的话,被替换字符带大括号的情况下是需要重新写的,下面例子中把它
      设置成了和不带大括号的<named>一样
      #+begin_src python 
        import re
        import string
        
        class MyTemplate(string.Template):
            delimiter = '{{'
            pattern = r'''
            \{\{(?:
            (?P<escaped>\{\{)|
            (?P<named>[_a-z][_a-z0-9]*)\}\}|
            (?P<braced>[_a-z][_a-z0-9]*)\}\}|
            (?P<invalide>)
            )
            '''
        t = MyTemplate('''
        {{{{
        {{var}}
        ''')
        
        print 'MATCHES:', t.pattern.findall(t.template)
        print 'SUBSTITUTED:', t.safe_substitute(var='replacement')
        
        # Output:
        # <============================================================================
        # MATCHES: [('{{', '', '', ''), ('', 'var', '', '')]
        # SUBSTITUTED: 
        # {{
        # replacement
        # ============================================================================>
      #+end_src
** textwrap--Formatting Text Paragraphs
*** Example Data
*** Filling Paragraphs
    + fill()函数把文本作为输入,制作输出
      #+begin_src python
        import textwrap
        
        sample_text = '''
            The textwrap module can be used to format text for output in
            situtations where pretty-prints is desired. It offers 
            programmatic functionality similar to the paragraph wrapping
            or filling features found inmany text editors.
           '''
        
        print 'No dedent:\n'
        print textwrap.fill(sample_text, width=50)   
        
        # Output:
        # <============================================================================
        # No dedent:
        
        #      The textwrap module can be used to format
        # text for output in     situtations where pretty-
        # prints is desired. It offers      programmatic
        # functionality similar to the paragraph wrapping
        # or filling features found inmany text editors.
        # ============================================================================>
      #+end_src
    + 效果貌似不理想,还是存在intent
*** Removing Existing Indentation
    + 去掉intent的方法:
      #+begin_src python
        import textwrap
        
        sample_text = '''
            The textwrap module can be used to format text for output in
            situtations where pretty-prints is desired. It offers 
            programmatic functionality similar to the paragraph wrapping
            or filling features found inmany text editors.
           '''
        
        
        print 'Dedent:'
        print textwrap.dedent(sample_text)
        
        # Output:
        # <============================================================================
        # Dedent:
        
        # The textwrap module can be used to format text for output in
        # situtations where pretty-prints is desired. It offers 
        # programmatic functionality similar to the paragraph wrapping
        # or filling features found inmany text editors.
        # ============================================================================>
      #+end_src
*** Combining Dedent and Fill
    + 吧dedented的text作为参数传给fill()就完成了两者的结合
            #+begin_src python
              import textwrap
              
              sample_text = '''
                  The textwrap module can be used to format text for output in
                  situtations where pretty-prints is desired. It offers 
                  programmatic functionality similar to the paragraph wrapping
                  or filling features found inmany text editors.
                 '''
              dedented_text = textwrap.dedent(sample_text).strip()
              for width in [45, 70]:
                  print '%d Columns:\n' % width
                  print textwrap.fill(dedented_text, width=width)
              
              # Output:
              # <============================================================================
              # 45 Columns:
              
              # The textwrap module can be used to format
              # text for output in situtations where pretty-
              # prints is desired. It offers  programmatic
              # functionality similar to the paragraph
              # wrapping or filling features found inmany
              # text editors.
              # 70 Columns:
              
              # The textwrap module can be used to format text for output in
              # situtations where pretty-prints is desired. It offers  programmatic
              # functionality similar to the paragraph wrapping or filling features
              # found inmany text editors. 
              # ============================================================================>
      #+end_src
*** 
