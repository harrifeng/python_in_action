#+OPTIONS: ^:{}
* Chapter 1:Text
** string: Text Constants and Templates
*** Functions
    + capwords()是大写首字母, 
      #+begin_src python
        import string
        
        s = 'The quick brown fox jumped over the lazy dog.'
        
        print s
        print string.capwords(s)
        
        # Output:
        # <==================================================================
        # The quick brown fox jumped over the lazy dog.
        # The Quick Brown Fox Jumped Over The Lazy Dog.
        # ==================================================================>
      #+end_src
    + maketrans是创建能让translate()函数试用的翻译表
      #+begin_src python
        import string
        
        leet = string.maketrans('abegiloprstz', '463611092572')
        
        s = 'The quick brown fox jumped over the lazy dog'
        
        print s
        print s.translate(leet)
        
        # Output:
        # <==================================================================
        # The quick brown fox jumped over the lazy dog
        # Th3 qu1ck 620wn f0x jum93d 0v32 7h3 142y d06
        # ==================================================================>
      #+end_src
*** Templates
    + Templates是用来从某个"字典"中取得数据然后输出, 和 string自身的那种
      format print相比,最大的区别是,template是没有字符类型的概念的,不需要
      知道是%d, %s, 还是%f. 注意${var}和$var其实是一样的，子所以还要加上{}
      是因为var是子字符串的情况。
      #+begin_src python
        import string
        
        #This is a dict, .i.e, var's value is foo
        values = { 
            'var':'foo' , 
            'num':234.2 
            } 
        
        t = string.Template("""
        Variable          : $var
        Escape            : $$
        Variable in text: ${var}iable
        """)
        
        print 'TEMPLATE:', t.substitute(values)
        
        s = """
        Variable          : %(var)s
        Escape            : %%
        Variable in text  : %(var)siable
        Number is         : %(num)f
        """
        
        print 'INTERPOLATION:', s % values
        
        # Output:
        # <==================================================================
        # TEMPLATE: 
        # Variable          : foo
        # Escape            : $
        # Variable in text: fooiable
        
        # INTERPOLATION: 
        # Variable          : foo
        # Escape            : %
        # Variable in text  : fooiable
        # Number is         : 234.200000
        # ==================================================================>
      #+end_src
    + 一个常见的良好做法是使用safe_substitute来代替substitute防止出现字典中某词
      不存在的情况
      #+begin_src python
        import string
        
        values = { 'var' : 'foo'}
        
        t = string.Template("$var is here but $missing is not provided")
        
        try:
            print 'substitute() way:', t.substitute(values)
        except KeyError, err:
            print 'ERROR:', str(err)
        
        print 'safe_substitute():', t.safe_substitute(values)    
        
        # Output:
        # <==================================================================
        # substitute() way: ERROR: 'missing'
        # safe_substitute(): foo is here but $missing is not provided
        # ==================================================================>
      #+end_src
*** Advanced Templates
    + string.Template也可以通过更改delimiter和idpattern两个attributes来实现更具体的替换
      - delimiter 用来更改提示符，默认提示符是$下面的例子就给他改成了%
      - idpattern 用来限制被替换的字符,只有满足两条:第一有提示符,第二符合idpattern的要求的字符串
	才可能被替换,比如下面的%with_underscore 一来有提示符,而来符合正则表达式[a-z]+_[a-z]+的
	的要求
      #+begin_src python 
        import string
        
        template_text = '''
          Delimiter : %%
          Replaced  : %with_underscore
          Ignored   : %notunderscored
        '''
        
        d = { 'with_underscore' : 'replaced',
              'notunderscored' : 'not replaced',
              }
        
        
        class MyTemplate(string.Template):
            delimiter = '%'  
            idpattern = '[a-z]+_[a-z]+'
        
        t = MyTemplate(template_text)
        print 'Modified ID pattern:'
        print t.safe_substitute(d)    
        
        # Output:
        # <==================================================================
        # Modified ID pattern:
        
        #   Delimiter : %
        #   Replaced  : replaced
        #   Ignored   : %notunderscored
        # ==================================================================>
      #+end_src
    + 除了更改idpattern，我们还可以选择更改pattern attribute,idpattern属于简单的修改
      (无法修改加括号的情况), 而更改pattern attribute那就很高端了,它可以更改四个属性:
      1) escaped 确定escape sequence
      2) 不加大括号的情况下的被替换字符形状
      3) 加大括号的情况下被替换字符的形状
      4) 某些特殊的情况,比如只有一个delimiter的情况
      下面,我们来看一下,默认的string.Template的pattern是什么样子的,可以通过新建一个
      string.Template来查看
      #+begin_src python
        import string
        
        # Construct a string.Template instance with a simple string argument
        t = string.Template('$var')
        print t.pattern.pattern
        
        # Output:
        # <==================================================================
            # \$(?:
            #   (?P<escaped>\$) |   # Escape sequence of two delimiters
            #   (?P<named>[_a-z][_a-z0-9]*)      |   # delimiter and a Python identifier
            #   {(?P<braced>[_a-z][_a-z0-9]*)}   |   # delimiter and a braced identifier
            #   (?P<invalid>)              # Other ill-formed delimiter exprs
            # )
        # ==================================================================>
        
      #+end_src
    + 下面看一个通过全部重写pattern attribute来进行字符串替换的例子, 可以看到这个例子中非常变态
      的把delimiter设置成了{{,这样的话,被替换字符带大括号的情况下是需要重新写的,下面例子中把它
      设置成了和不带大括号的<named>一样
      #+begin_src python 
        import re
        import string
        
        class MyTemplate(string.Template):
            delimiter = '{{'
            pattern = r'''
            \{\{(?:
            (?P<escaped>\{\{)|
            (?P<named>[_a-z][_a-z0-9]*)\}\}|
            (?P<braced>[_a-z][_a-z0-9]*)\}\}|
            (?P<invalide>)
            )
            '''
        t = MyTemplate('''
        {{{{
        {{var}}
        ''')
        
        print 'MATCHES:', t.pattern.findall(t.template)
        print 'SUBSTITUTED:', t.safe_substitute(var='replacement')
        
        # Output:
        # <==================================================================
        # MATCHES: [('{{', '', '', ''), ('', 'var', '', '')]
        # SUBSTITUTED: 
        # {{
        # replacement
        # ==================================================================>
      #+end_#+byegin_src c++ 
      #+end_src

** textwrap--Formatting Text Paragraphs
*** Example Data
*** Filling Paragraphs
    + fill()函数把文本作为输入,制作输出
      #+begin_src python
        import textwrap
        
        sample_text = '''
            The textwrap module can be used to format text for output in
            situtations where pretty-prints is desired. It offers 
            programmatic functionality similar to the paragraph wrapping
            or filling features found inmany text editors.
           '''
        
        print 'No dedent:\n'
        print textwrap.fill(sample_text, width=50)   
        
        # Output:
        # <==================================================================
        # No dedent:
        #
        #      The textwrap module can be used to format
        # text for output in     situtations where pretty-
        # prints is desired. It offers      programmatic
        # functionality similar to the paragraph wrapping
        # or filling features found inmany text editors.
        # ==================================================================>
      #+end_src
    + 效果貌似不理想,还是存在intent
*** Removing Existing Indentation
    + 去掉intent的方法:
      #+begin_src python
        import textwrap
        
        sample_text = '''
            The textwrap module can be used to format text for output in
            situtations where pretty-prints is desired. It offers 
            programmatic functionality similar to the paragraph wrapping
            or filling features found inmany text editors.
           '''
        
        
        print 'Dedent:'
        print textwrap.dedent(sample_text)
        
        # Output:
        # <==================================================================
        # Dedent:
        #
        # The textwrap module can be used to format text for output in
        # situtations where pretty-prints is desired. It offers 
        # programmatic functionality similar to the paragraph wrapping
        # or filling features found inmany text editors.
        # ==================================================================>
      #+end_src
*** Combining Dedent and Fill
    + 吧dedented的text作为参数传给fill()就完成了两者的结合
            #+begin_src python
              import textwrap
              
              sample_text = '''
                  The textwrap module can be used to format text for output in
                  situtations where pretty-prints is desired. It offers 
                  programmatic functionality similar to the paragraph wrapping
                  or filling features found inmany text editors.
                 '''
              dedented_text = textwrap.dedent(sample_text).strip()
              for width in [45, 70]:
                  print '%d Columns:\n' % width
                  print textwrap.fill(dedented_text, width=width)
              
              # Output:
              # <==================================================================
              # 45 Columns:
              #
              # The textwrap module can be used to format
              # text for output in situtations where pretty-
              # prints is desired. It offers  programmatic
              # functionality similar to the paragraph
              # wrapping or filling features found inmany
              # text editors.
              # 70 Columns:
              #
              # The textwrap module can be used to format text for output in
              # situtations where pretty-prints is desired. It offers  programmatic
              # functionality similar to the paragraph wrapping or filling features
              # found inmany text editors. 
              # ==================================================================>
      #+end_src
*** Hanging Indentsy
    + 输出的宽度可以被设置,同样的缩进大小也可以被设置
      #+begin_src python
        import textwrap
        
        sample_text = '''
            The textwrap module can be used to format text for output in
            situtations where pretty-prints is desired. It offers 
            programmatic functionality similar to the paragraph wrapping
            or filling features found inmany text editors.
           '''
        dedented_text = textwrap.dedent(sample_text).strip()
        print textwrap.fill(dedented_text,
                            initial_indent='',
                            subsequent_indent=' ' * 4,
                            width=50,
                            )
        
        # Output:
        # <==================================================================
        # The textwrap module can be used to format text for
        #     output in situtations where pretty-prints is
        #     desired. It offers  programmatic functionality
        #     similar to the paragraph wrapping or filling
        #     features found inmany text editors.
        # ==================================================================>
      #+end_src
** re--Regular Expressions
*** Finding Patterns in Text
    + re最常用的地方应该就是寻找字符串,也就是search()函数, 如果没有匹配字符串search()返回None,
      如果找到了,则返回Match object
    + Match object含有很多内容, 比如原始正则表达式是什么, 在哪里找到的,找到的字符串是什么
      #+begin_src python
        import re
        
        pattern = 'this'
        text = 'Does this text match the pattern?'
        
        match = re.search(pattern, text)
        
        s = match.start()
        e = match.end()
        
        print 'Found "%s"\n in "%s"\nfrom %d to %d ("%s")' % \
          (match.re.pattern, match.string, s, e, text[s:e])
        
        # Output:
        # <==================================================================
        # Found "this"
        #  in "Does this text match the pattern?"
        # from 5 to 9 ("this") 
        # ==================================================================>
      #+end_src
*** Compiling Expressions
    + 如果经常使用,可以把某个字符通过compile()函数来转化成RegexObject
      #+begin_src python
        import re
        
        #Precompile the patterns
        regexes = [re.compile(p)
                   for p in ['this', 'that']
                   ]
        text = 'Does this text match the pattern?'
        
        print 'Text: %r\n' % text
        
        for regex in regexes:
            print 'Seeking "%s" ->' % regex.pattern,
        
            if regex.search(text):
                print 'match!'
            else:
                print 'no match'
        
        # Output:
        # <==================================================================
        # Text: 'Does this text match the pattern?'
        #
        # Seeking "this" -> match!
        # Seeking "that" -> no match
        # ==================================================================>
      #+end_src
    + 前面的module(search函数)会维护一个cache,但是cache大小有限制,使用了compiled expression后
      我们可以直接减去查找cache的消耗
    + 另外一个好处就是complied的话,可以使得工作都集中在导入阶段,如果有用户交互的话,时间差就不会被
      用户所感觉到.
*** Multiple Matches
    + 如果有多个匹配的查找结果,我们就要依靠findall函数了. findall函数返回匹配的字符串结果
      #+begin_src python
        import re
        
        text = 'abbaaabbbbaaaaa'
        pattern = 'ab'
        
        for match in re.findall(pattern, text):
            print 'Found "%s"' % match
        
        # Output:
        # <==================================================================
        # Found "ab"
        # Found "ab"
        # ==================================================================>
      #+end_src
    + 如果想知道匹配字符串的位置可以使用finditer函数
      #+begin_src python
        import re
        
        text = 'abbaaabbbbaaaaa'
        pattern = 'ab'
        
        for match in re.finditer(pattern, text):
            s = match.start()
            e = match.end()
            print 'Found "%s" at %d:%d' % (text[s:e], s, e)
        
        # Output:
        # <==================================================================
        # Found "ab" at 0:2
        # Found "ab" at 5:7
        # ==================================================================>  
      #+end_src
*** Pattern Syntax
    + 我们还可以通过像'.'这种meta character来使得我们的查找结果更明显
      #+begin_src python
        import re 
        
        def test_patterns(text, patterns=[]):
            """Given source text and a list of patterns, look for
            matches for each pattern within the text and print
            them to stdout.
            """
            for pattern, desc in patterns:
                print 'Pattern %r (%s)\n' % (pattern, desc)
                print '  %r'  % text
                for match in re.finditer(pattern, text):
                    s = match.start()
                    e = match.end()
                    substr = text[s:e]
                    n_backslashes = text[:s].count('\\')
                    prefix = '.' * (s + n_backslashes)
                    print '  %s%r' % (prefix, substr)
                print
            return
        
        if __name__ == '__main__':
            test_patterns('abbaaabbbbaaaaa',
                          [('ab', "'a' followd by 'b'"),
                           ])
        # Output:
        # <==================================================================
        # Pattern 'ab' ('a' followd by 'b')
        #
        #   'abbaaabbbbaaaaa'
        #   'ab'
        #   .....'ab' 
        # ==================================================================>
      #+end_src
**** Repetition
     + 下面是关于正则表达式中表达"重复"的例子
        #+begin_src python
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns('abbaaabbbbaaaaa',
                           [('ab*',       'a followed by zero or more b'),
                            ('ab+',       'a followed by one or more b'),
                            ('ab?',       'a followed by zero or one b'),
                            ('ab{3}',     'a followed by three b'),
                            ('ab{2,3}',   'a followed by tow to  three b'),
                            ])
         # Output:
         # <==================================================================
         #  Pattern 'ab*' (a followed by zero or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   ...'a'
         #   ....'a'
         #   .....'abbbb'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab+' (a followed by one or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   .....'abbbb'
         # 
         # Pattern 'ab?' (a followed by zero or one b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   ...'a'
         #   ....'a'
         #   .....'ab'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab{3}' (a followed by three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   .....'abbb'
         # 
         # Pattern 'ab{2,3}' (a followed by tow to  three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   .....'abbb'
         #  Pattern 'ab*' (a followed by zero or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   ...'a'
         #   ....'a'
         #   .....'abbbb'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab+' (a followed by one or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   .....'abbbb'
         # 
         # Pattern 'ab?' (a followed by zero or one b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   ...'a'
         #   ....'a'
         #   .....'ab'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab{3}' (a followed by three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   .....'abbb'
         # 
         # Pattern 'ab{2,3}' (a followed by tow to  three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   .....'abbb'
         # ==================================================================>
       #+end_src
     + 归纳起来,重复就有如下五种方式
       1) * 表示0或者多次重复
       2) + 表示1或者多次重复
       3) ? 表示0或者1次重复
       4) {m}表示必须重复m次
       5) {m,n}表示重复最少m次,最多n次: {m,}表示最少m次,多了不限
     + 默认的正则表达式是贪婪匹配,可以通过在pattern最后加上?来关闭贪婪匹配
       #+begin_src python
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns('abbaaabbbbaaaaa',
                           [('ab*?',       'a followed by zero or more b'),
                            ('ab+?',       'a followed by one or more b'),
                            ('ab??',       'a followed by zero or one b'),
                            ('ab{3}?',     'a followed by three b'),
                            ('ab{2,3}?',   'a followed by tow to  three b'),
                            ])
         # Output:
         # <==================================================================
         # Pattern 'ab*?' (a followed by zero or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'a'
         #   ...'a'
         #   ....'a'
         #   .....'a'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab+?' (a followed by one or more b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   .....'ab'
         # 
         # Pattern 'ab??' (a followed by zero or one b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'a'
         #   ...'a'
         #   ....'a'
         #   .....'a'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'ab{3}?' (a followed by three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   .....'abbb'
         # 
         # Pattern 'ab{2,3}?' (a followed by tow to  three b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   .....'abb'
         # ==================================================================>
       #+end_src
**** Character Sets
     + 所谓Character Sets就是一组的字符里面任何一个匹配成功都算成功,比如对于[ab]来说,a和b都
       算匹配成功
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns('abbaaabbbbaaaaa',
                           [('[ab]',       'either a or b'),
                            ('a[ab]+',      'a followed by 1 or more a or b'),
                            ('a[ab]+?',     'a followed by 1 or more a or b, not greedy'),
                            ])
         # Output:
         # <==================================================================
         # Pattern '[ab]' (either a or b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'a'
         #   .'b'
         #   ..'b'
         #   ...'a'
         #   ....'a'
         #   .....'a'
         #   ......'b'
         #   .......'b'
         #   ........'b'
         #   .........'b'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'a[ab]+' (a followed by 1 or more a or b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abbaaabbbbaaaaa'
         # 
         # Pattern 'a[ab]+?' (a followed by 1 or more a or b, not greedy)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   ...'aa'
         #   .....'ab'
         #   ..........'aa'
         #   ............'aa'
         # ==================================================================>
       #+end_src
     + 还可以用carat(^)加在character sets里面来排除某些字符
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns(
             'This is some text -- with punctuation.',
             [ ('[^-. ]+', 'sequences without -, ., or space'),
               ])
         
         # Output:
         # <==================================================================
         # Pattern '[^-. ]+' (sequences without -, ., or space)
         # 
         #   'This is some text -- with punctuation.'
         #   'This'
         #   .....'is'
         #   ........'some'
         #   .............'text'
         #   .....................'with'
         #   ..........................'punctuation' 
         # ==================================================================>
       #+end_src
     + 如果字符多的情况下,一个个在[]中列出来显然不是特别现实,这种情况下character range就显得
       特别有用,其使用方法就是在[]中写上ascii字符范围
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns(
             'This is some text -- with punctuation.',
             [ ('[a-z]+', 'sequences of lowercase letters'),
               ('[A-Z]+', 'sequences of uppercase letters'),
               ('[a-zA-Z]+', 'sequences of lowercase or uppercase letters'),
               ('[A-Z][a-z]+', 'one uppercase followed by lowercase'),
               ])
         
         # Output:
         # <==================================================================
         # Pattern '[a-z]+' (sequences of lowercase letters)
         # 
         #   'This is some text -- with punctuation.'
         #   .'his'
         #   .....'is'
         #   ........'some'
         #   .............'text'
         #   .....................'with'
         #   ..........................'punctuation'
         # 
         # Pattern '[A-Z]+' (sequences of uppercase letters)
         # 
         #   'This is some text -- with punctuation.'
         #   'T'
         # 
         # Pattern '[a-zA-Z]+' (sequences of lowercase or uppercase letters)
         # 
         #   'This is some text -- with punctuation.'
         #   'This'
         #   .....'is'
         #   ........'some'
         #   .............'text'
         #   .....................'with'
         #   ..........................'punctuation'
         # 
         # Pattern '[A-Z][a-z]+' (one uppercase followed by lowercase)
         # 
         #   'This is some text -- with punctuation.'
         #   'This'
         # ==================================================================>
       #+end_src
     + period(.)是非常特殊的一种character sets,在匹配里面,它可以表示任意字符,也就是说它用
       character set表示的话就是[ascii开始-ascii结束], period如果再和前面的五种重复一块
       使用,会产生非常长的结果,比如下面的'a.*b', 最后产生了一个匹配'abbaaabbbb',使用非贪婪匹
       配会好很多,比如下面的'a.*?b',得到的结果也更合理.
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns('abbaaabbbbaaaaa',
                           [('a.',         'a followed by any one character'),
                            ('b.',         'b followed by any one character'),
                            ('a.*b',      'a followed by anything, ending in b'),
                            ('a.*?b',     'a followed by anything, ending in b'),
                            ])
         
         # # Output:
         # # <==================================================================
         # Pattern 'a.' (a followed by any one character)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   ...'aa'
         #   .....'ab'
         #   ..........'aa'
         #   ............'aa'
         # 
         # Pattern 'b.' (b followed by any one character)
         # 
         #   'abbaaabbbbaaaaa'
         #   .'bb'
         #   ......'bb'
         #   ........'bb'
         # 
         # Pattern 'a.*b' (a followed by anything, ending in b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abbaaabbbb'
         # 
         # Pattern 'a.*?b' (a followed by anything, ending in b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'ab'
         #   ...'aaab'
         # ==================================================================>
       #+end_src
**** Escape Codes
     + 更抽象的表示是转义码,如下图
       | Code | Meaning                               |
       |------+---------------------------------------|
       | \d   | A digit                               |
       | \D   | A nondigit                            |
       | \s   | Whitespace(tab, space, newline, etc.) |
       | \S   | Nonwhitespace                         |
       | \w   | Alphanumeric                          |
       | \W   | Nonalphanumeric                       |
     + 所有的转义码前面都有一"\", 但是在普通python string里面,如果要显示出"\", 需要"\\", 而且也
       更难以阅读和理解.所以我们在使用转义码的时候,不使用普通pythong string,而是使用raw string,
       也就是在文本字符串前面加个"r"
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns(
                 'A prime #1 example!',
                 [ (r'\d+', 'sequence of digits'),
                   (r'\D+', 'sequence of nondigits'),
                   (r'\s+', 'sequence of whitespace'),
                   (r'\S+', 'sequence of nonwhitespace'),
                   (r'\w+', 'alphanumeric characters'),
                   (r'\W+', 'nonalphanumeric characters'),
                   ])
         
         # Output:
         # <==================================================================
         # Pattern '\\d+' (sequence of digits)
         # 
         #   'A prime #1 example!'
         #   .........'1'
         # 
         # Pattern '\\D+' (sequence of nondigits)
         # 
         #   'A prime #1 example!'
         #   'A prime #'
         #   ..........' example!'
         # 
         # Pattern '\\s+' (sequence of whitespace)
         # 
         #   'A prime #1 example!'
         #   .' '
         #   .......' '
         #   ..........' '
         # 
         # Pattern '\\S+' (sequence of nonwhitespace)
         # 
         #   'A prime #1 example!'
         #   'A'
         #   ..'prime'
         #   ........'#1'
         #   ...........'example!'
         # 
         # Pattern '\\w+' (alphanumeric characters)
         # 
         #   'A prime #1 example!'
         #   'A'
         #   ..'prime'
         #   .........'1'
         #   ...........'example'
         # 
         # Pattern '\\W+' (nonalphanumeric characters)
         # 
         #   'A prime #1 example!'
         #   .' '
         #   .......' #'
         #   ..........' '
         #   ..................'!' 
         # ==================================================================>
       #+end_src
**** Anchoring
     + 如果需要匹配字符串出现的相对位置(字串头,字串尾), 那么就需要用到"锚定"
       | Code | Meaning                                            |
       |------+----------------------------------------------------|
       | (^)  | Start of string, or line                           |
       | ($)  | End of string, or line                             |
       | (\A) | Start of string                                    |
       | (\Z) | End of string                                      |
       | (\b) | Empty string at the beginning or end of a word     |
       | (\B) | Empty string not at the beginning or end of a word |
       
     + 下面的例子中匹配开头用了'^\w+', 按说这里的匹配结尾应该用'\w+$', 但是
       因为这个原始字符串中有句号".",它不属于任何的字母,所以我们用'\S*'来匹配.
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns(
                 'This is some text -- with punctuation.',
                 [ (r'^\w+',    'word at start of string'),
                   (r'\A\w+',   'word at start of string'),
                   (r'\w+\S*$', 'word near end of string, skip punctuation'),
                   (r'\w+\S*\Z','word near end of string, skip punctuation'),
                   (r'\w*t\w*', 'word containing t'),
                   (r'\bt\w+',  't at start of word'),
                   (r'\w+t\b',  't at end of word'),
                   (r'\Bt\B',   't, not start or end of word'),
                   ])
         
         # Output:
         # <==================================================================
         # Pattern '^\\w+' (word at start of string)
         # 
         #   'This is some text -- with punctuation.'
         #   'This'
         # 
         # Pattern '\\A\\w+' (word at start of string)
         # 
         #   'This is some text -- with punctuation.'
         #   'This'
         # 
         # Pattern '\\w+\\S*$' (word near end of string, skip punctuation)
         # 
         #   'This is some text -- with punctuation.'
         #   ..........................'punctuation.'
         # 
         # Pattern '\\w+\\S*\\Z' (word near end of string, skip punctuation)
         # 
         #   'This is some text -- with punctuation.'
         #   ..........................'punctuation.'
         # 
         # Pattern '\\w*t\\w*' (word containing t)
         # 
         #   'This is some text -- with punctuation.'
         #   .............'text'
         #   .....................'with'
         #   ..........................'punctuation'
         # 
         # Pattern '\\bt\\w+' (t at start of word)
         # 
         #   'This is some text -- with punctuation.'
         #   .............'text'
         # 
         # Pattern '\\w+t\\b' (t at end of word)
         # 
         #   'This is some text -- with punctuation.'
         #   .............'text'
         # 
         # Pattern '\\Bt\\B' (t, not start or end of word)
         # 
         #   'This is some text -- with punctuation.'
         #   .......................'t'
         #   ..............................'t'
         #   .................................'t'
         # ==================================================================>
       #+end_src
*** Constraining the Search
    + 如果搜索范围有限定,比如一定是从可以用match()来替代search()
       #+begin_src python 
         import re 
         
         text = 'This is some text -- with punctuation.'
         pattern = 'is'
         
         print 'Text    :', text
         print 'Pattern :', pattern
         
         m = re.match(pattern, text)
         print 'Match   :', m
         s = re.search(pattern, text)
         print 'Search  :', s
         
         # Output:
         # <==================================================================
         # Text    : This is some text -- with punctuation.
         # Pattern : is
         # Match   : None
         # Search  : <_sre.SRE_Match object at 0x02642138>
         # ==================================================================>
       #+end_src
    + search函数还可以接受额外的参数来确定搜索范围, 下面的例子其实就是一个效率较差版本的iterall()
      #+begin_src python
        import re
        
        text = 'This is some text -- with punctuation.'
        pattern = re.compile(r'\b\w*is\w*\b')
        
        print 'Text:', text
        print
        
        pos = 0
        while True:
            match = pattern.search(text, pos)
            if not match:
                break
            s = match.start()
            e = match.end()
            print '   %2d : %2d = "%s"' % \
              (s, e-1, text[s:e])
            # Move forward in text for the next search      
            pos = e
        
        # Output:
        # <==================================================================
        # Text: This is some text -- with punctuation.
        # 
        #     0 :  3 = "This"
        #     5 :  6 = "is" 
        # ==================================================================>
      #+end_src
*** Dissecting Matches with Groups
    + 通过括号(),可以把匹配字符分成几份,更增加匹配的扩展性
       #+begin_src python 
         import re 
         
         def test_patterns(text, patterns=[]):
             """Given source text and a list of patterns, look for
             matches for each pattern within the text and print
             them to stdout.
             """
             for pattern, desc in patterns:
                 print 'Pattern %r (%s)\n' % (pattern, desc)
                 print '  %r'  % text
                 for match in re.finditer(pattern, text):
                     s = match.start()
                     e = match.end()
                     substr = text[s:e]
                     n_backslashes = text[:s].count('\\')
                     prefix = '.' * (s + n_backslashes)
                     print '  %s%r' % (prefix, substr)
                 print
             return
         
         if __name__ == '__main__':
             test_patterns(
                 'abbaaabbbbaaaaa',
                 [ ('a(ab)',    'a followed by literal ab'),
                   ('a(a*b*)',  'a followed by 0-n a and 0-n b'),
                   ('a(ab)*',   'a followed by 0-n ab'),
                   ('a(ab)+',   'a followed by 1-n ab'),
                   ])
         
         # Output:
         # <==================================================================
         # Pattern 'a(ab)' (a followed by literal ab)
         # 
         #   'abbaaabbbbaaaaa'
         #   ....'aab'
         # 
         # Pattern 'a(a*b*)' (a followed by 0-n a and 0-n b)
         # 
         #   'abbaaabbbbaaaaa'
         #   'abb'
         #   ...'aaabbbb'
         #   ..........'aaaaa'
         # 
         # Pattern 'a(ab)*' (a followed by 0-n ab)
         # 
         #   'abbaaabbbbaaaaa'
         #   'a'
         #   ...'a'
         #   ....'aab'
         #   ..........'a'
         #   ...........'a'
         #   ............'a'
         #   .............'a'
         #   ..............'a'
         # 
         # Pattern 'a(ab)+' (a followed by 1-n ab)
         # 
         #   'abbaaabbbbaaaaa'
         #   ....'aab'
         # ==================================================================>
       #+end_src
    + search()返回一个Match Object, 可以用这个object的函数goups()把结果合并起来, 在pattern中
      每一个()会产生一个匹配结果.比如下面例子中,只有r'(\bt\w+)\W+(\w)' 会产生两个结果
      #+begin_src python
        import re
        
        text = 'This is some text -- with punctuation.'
        
        print text
        print
        
        patterns = [
            (r'^(\w+)',           'word at start of string'),
            (r'(\w+)\S*$',        'word at end, with optional punctuation'),
        # There will be two members in the result, as there are two '()', here
            (r'(\bt\w+)\W+(\w)',  'word starting with t, another word'),
            (r'(\w+t)\b',         'word ending with t'),
            ]
        
        for pattern, desc in patterns:
            regex = re.compile(pattern)
            match = regex.search(text)
            print 'Pattern %r (%s)\n' % (pattern, desc)
            print '    ', match.groups()
            print
        
        # Output:
        # <==================================================================
        # This is some text -- with punctuation.
        # 
        # Pattern '^(\\w+)' (word at start of string)
        # 
        #      ('This',)
        # 
        # Pattern '(\\w+)\\S*$' (word at end, with optional punctuation)
        # 
        #      ('punctuation',)
        # 
        # Pattern '(\\bt\\w+)\\W+(\\w)' (word starting with t, another word)
        # 
        #      ('text', 'w')
        # 
        # Pattern '(\\w+t)\\b' (word ending with t)
        # 
        #      ('text',)
        # ==================================================================>
      #+end_src
    + 除了groups(),还可以使用group(),group(0)是全匹配的结果,group(n)是依次下来的匹配结果
      #+begin_src python
        import re
        
        text = 'This is some text == with punctuation.'
        
        print 'Input text              :', text
        
        
        #word starting with 't' then another word
        regex = re.compile(r'(\bt\w+)\W+(\w+)')
        print 'Pattern                 :', regex.pattern
        
        match = regex.search(text)
        print 'Entire match            :', match.group(0)
        print 'Word starting with "t"  :', match.group(1)
        print 'Word after "t" word     :', match.group(2)
        
        # Output:
        # <==================================================================
        # Input text              : This is some text == with punctuation.
        # Pattern                 : (\bt\w+)\W+(\w+)
        # Entire match            : text == with
        # Word starting with "t"  : text
        # Word after "t" word     : with
        # ==================================================================>
      #+end_src
    + python还对基本的分组增加了命名组功能,用name来命名group可以使得日后更改pattern变得容易
      #+begin_src python
        import re      
        
        text = 'This is some text -- with punctuation.'
        
        print text
        print
        
        for pattern in [ r'^(?P<first_word>\w+)',
                         r'(?P<last_word>\w)\S*$',
                         r'(?P<t_word>\bt\w+)\W+(?P<other_word>\w+)',
                         r'(?P<ends_with_t>\w+t)\b',
                         ]:
            regex = re.compile(pattern)
            match = regex.search(text)
            print 'Matching "%s"' % pattern
            print '   ', match.groups()
            print '   ', match.groupdict()
            print 
        
        # Output:
        # <==================================================================
        # This is some text -- with punctuation.
        # 
        # Matching "^(?P<first_word>\w+)"
        #     ('This',)
        #     {'first_word': 'This'}
        # 
        # Matching "(?P<last_word>\w)\S*$"
        #     ('p',)
        #     {'last_word': 'p'}
        # 
        # Matching "(?P<t_word>\bt\w+)\W+(?P<other_word>\w+)"
        #     ('text', 'with')
        #     {'other_word': 'with', 't_word': 'text'}
        # 
        # Matching "(?P<ends_with_t>\w+t)\b"
        #     ('text',)
        #     {'ends_with_t': 'text'} 
        # ==================================================================>
      #+end_src
    + 我们来用刚才学过的知识来更新test_pattern如下, 这个例子能够更好的理解groups
      - 我们说了一个()就是一个group,那么下面的r'a((a*)(b*))'就是包含了三个group
      - match.groups()的结果,表明,最外面的()是groups的第一个值,然后是(a*), (b*)
      - 由于(a*)和(b*)都有可能是空字符串,所以''也有出现
      #+begin_src python
        import re
        
        def test_patterns(text, patterns=[]):
            """ Given source text and a list of patterns, look fo
            matches for each pattern within the text and print 
            them to stdout.
            """
            # Look for each pattern in the text and print the results
            for pattern, desc in patterns:
                print 'Pattern %r (%s) \n' % (pattern, desc)
                print '   %r' % text
                for match in re.finditer(pattern, text):
                    s = match.start()
                    e = match.end()
                    prefix = ' ' * (s)
                    print '   %s%r%s ' % (prefix, text[s:e], ' '*(len(text)-e)),
                    print match.groups()
                    if match.groupdict():
                        print '%s%s' % (' ' * (len(text)-s), match.groupdict())
                print
            return
        
        test_patterns(
            'abbaabbba',
            [ (r'a((a*)(b*))', 'a followed by 0-n a and 0-n b'),
              ])
        
        # Output:
        # <==================================================================
        # Pattern 'a((a*)(b*))' (a followed by 0-n a and 0-n b) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb', '', 'bb')
        #       'aabbb'   ('abbb', 'a', 'bbb')
        #            'a'  ('', '', '')
        # ==================================================================>
      #+end_src
    + group还可以和或(|)联合起来使用,表示其中有个能够匹配即可.注意(|)位置的不同,会造成截然不同
      的结果,下面例子中的((a|b)+)和((a+)|(b+))就不相同,前者表示只要是ab相连即可,后者要求要么
      全是a,要么全是b(如果你注意观察会发现,前者是两个group,而后者是三个group
    + 这个例子中的group匹配因为有或(|)的参与,所以会出现某些子group根本不匹配的情况,python会
      选择输出None表示
      #+begin_src python
        import re
        
        def test_patterns(text, patterns=[]):
            """ Given source text and a list of patterns, look fo
            matches for each pattern within the text and print 
            them to stdout.
            """
            # Look for each pattern in the text and print the results
            for pattern, desc in patterns:
                print 'Pattern %r (%s) \n' % (pattern, desc)
                print '   %r' % text
                for match in re.finditer(pattern, text):
                    s = match.start()
                    e = match.end()
                    prefix = ' ' * (s)
                    print '   %s%r%s ' % (prefix, text[s:e], ' '*(len(text)-e)),
                    print match.groups()
                    if match.groupdict():
                        print '%s%s' % (' ' * (len(text)-s), match.groupdict())
                print
            return
        
        test_patterns(
            'abbaabbba',
            [ (r'a((a+)|(b+))', 'a then seq. of a or seq. of b'),
              (r'a((a|b)+)',  'a then seq. of [ab]'),
              ])
        
        # Output:
        # <==================================================================
        # Pattern 'a((a+)|(b+))' (a then seq. of a or seq. of b) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb', None, 'bb')
        #       'aa'      ('a', 'a', None)
        # 
        # Pattern 'a((a|b)+)' (a then seq. of [ab]) 
        # 
        #    'abbaabbba'
        #    'abbaabbba'  ('bbaabbba', 'a')
        # ==================================================================>
      #+end_src
    + 如果我们对某些子group产生的结果不感兴趣,我们可以用?:来把这些子group标记为noncapturing的
      这样在match object groups函数里面就不会有这些部分的痕迹了.
      #+begin_src python
        import re
        
        def test_patterns(text, patterns=[]):
            """ Given source text and a list of patterns, look fo
            matches for each pattern within the text and print 
            them to stdout.
            """
            # Look for each pattern in the text and print the results
            for pattern, desc in patterns:
                print 'Pattern %r (%s) \n' % (pattern, desc)
                print '   %r' % text
                for match in re.finditer(pattern, text):
                    s = match.start()
                    e = match.end()
                    prefix = ' ' * (s)
                    print '   %s%r%s ' % (prefix, text[s:e], ' '*(len(text)-e)),
                    print match.groups()
                    if match.groupdict():
                        print '%s%s' % (' ' * (len(text)-s), match.groupdict())
                print
            return
        
        test_patterns(
            'abbaabbba',
            [ (r'a((a+)|(b+))',     'capturing form'),
              (r'a((a+)|(?:b+))',   'noncapturing form, do not care about a'),
              (r'a((?:a+)|(b+))',   'noncapturing form, do not care about b'),
              (r'a((?:a+)|(?:b+))', 'noncapturing form, do not care about a or b'),
              ])
        
        # Output:
        # <==================================================================
        # Pattern 'a((a+)|(b+))' (capturing form) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb', None, 'bb')
        #       'aa'      ('a', 'a', None)
        # 
        # Pattern 'a((a+)|(?:b+))' (noncapturing form, do not care about a) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb', None)
        #       'aa'      ('a', 'a')
        # 
        # Pattern 'a((?:a+)|(b+))' (noncapturing form, do not care about b) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb', 'bb')
        #       'aa'      ('a', None)
        # 
        # Pattern 'a((?:a+)|(?:b+))' (noncapturing form, do not care about a or b) 
        # 
        #    'abbaabbba'
        #    'abb'        ('bb',)
        #       'aa'      ('a',)
        # ==================================================================>
      #+end_src
*** Search Options
    + 搜索的时候可以选择很多的选项,比如是否大小写敏感.等等. 
**** Case-Insensitive Matching
     + 搜索的时候用IGNORECASE变量来设置不敏感
       #+begin_src python
         import re
         
         text = 'This is some text -- with punctuation.'
         pattern = r'\bT\w+'
         with_case = re.compile(pattern)
         without_case = re.compile(pattern, re.IGNORECASE)
         
         print 'Text:\n  %r'  % text
         print 'Pattern:\n %s' % pattern
         print 'Case-sensitive:'
         for match in with_case.findall(text):
             print '   %r' % match
         print 'Case-insensitive:'
         for match in without_case.findall(text):
             print '   %r' % match
         
         # Output:
         # <==================================================================
         # Text:
         #   'This is some text -- with punctuation.'
         # Pattern:
         #  \bT\w+
         # Case-sensitive:
         #    'This'
         # Case-insensitive:
         #    'This'
         #    'text'
         # ==================================================================>
       #+end_src
     + MULTILINE变量可以设置成把带换行符(\n)的字符串当做是多行字符串,在每行字符串都匹配开头和结尾
       两个锚定规则(^和$)
       #+begin_src python
         import re
         
         text = 'This is some text -- with punctuation.\nA second line.'
         pattern = r'(^\w+)|(\w+\S*$)'
         single_line = re.compile(pattern)
         multiline = re.compile(pattern, re.MULTILINE)
         
         print 'Text:\n   %r' % text
         print 'Pattern: \n %s' % pattern
         print 'Single Line :'
         for match in single_line.findall(text):
             print '   %r' % (match,)
         print 'Multiline   :'
         for match in multiline.findall(text):
             print '   %r' % (match,)
         
         # Output:
         # <==================================================================
         # Text:
         #    'This is some text -- with punctuation.\nA second line.'
         # Pattern: 
         #  (^\w+)|(\w+\S*$)
         # Single Line :
         #    ('This', '')
         #    ('', 'line.')
         # Multiline   :
         #    ('This', '')
         #    ('', 'punctuation.')
         #    ('A', '')
         #    ('', 'line.')
         # ==================================================================>
       #+end_src
     + 一般情况下,dot character(.)是可以匹配除了换行符以外的任意的字符, 而加了DOTALL以后, dot 
       character就同时可以匹配换行符了.
       #+begin_src python
         import re
         
         text = 'This is some text -- with punctuation.\nA second line.'
         pattern = r'.+'
         no_newlines = re.compile(pattern)
         dotall = re.compile(pattern, re.DOTALL)
         
         print 'Text:\n %r' % text
         print 'Pattern:\n %s' % pattern
         print 'No newlines :'
         for match in no_newlines.findall(text):
             print '   %r' % match
         print 'Dotall      :'
         for match in dotall.findall(text):
             print '   %r' % match
         
         # Output:
         # <==================================================================
         # Text:
         #  'This is some text -- with punctuation.\nA second line.'
         # Pattern:
         #  .+
         # No newlines :
         #    'This is some text -- with punctuation.'
         #    'A second line.'
         # Dotall      :
         #    'This is some text -- with punctuation.\nA second line.' 
         # ==================================================================>
       #+end_src
**** Unicode
     + 对于python 2来说, 所有的字符串都默认是ASCII,所以\w+能够匹配"French", 但是却无法匹配法语
       'Français', 所以我们需要UNICODE flag.
     + python 3默认都使用unicode,所以这个flag在python3中是没有用了
       #+begin_src python
         # -*- coding:utf-8 -*-
         import re
         import codecs
         import sys
         
         # Set standard output encoding to UTF-8
         sys.stdout = codecs.getwriter('UTF-8')(sys.stdout)
         
         text = u'Français zloty Österreich'
         pattern = ur'\w+'
         ascii_pattern = re.compile(pattern)
         unicode_pattern = re.compile(pattern, re.UNICODE)
         
         print 'Text    :', text
         print 'Pattern :', pattern
         print 'ASCII   :', u', '.join(ascii_pattern.findall(text))
         print 'Unicode :', u', '.join(unicode_pattern.findall(text))
         
         # Output:
         # <==================================================================
         # Text    : Français zloty Österreich
         # Pattern : \w+
         # ASCII   : Fran, ais, zloty, sterreich
         # Unicode : Français zloty Österreich
         # ==================================================================>
       #+end_src
**** Verbose Expression Syntax
     + 下面是一个检测邮箱地址是否合法的程序,我们发现这个正则表达式实在是太长了,也不好理解
       #+begin_src python 
         import re
         
         address = re.compile('[\w\d.+-]+@([\w\d.]+\.)+(com|org|edu)',
                              re.UNICODE)
         
         candidates = [
             u'first.last@example.com',
             u'first.last+category@gmail.com',
             u'valid-address@mail.example.com',
             u'not-valid@example.foo',
             ]
         
         for candidate in candidates:
             match = address.search(candidate)
             print '%-30s %s' % (candidate, 'Matches' if match else 'NO match')
         
         # Output:
         # <==================================================================
         # first.last@example.com         Matches
         # first.last+category@gmail.com  Matches
         # valid-address@mail.example.com Matches
         # not-valid@example.foo          NO match 
         # ==================================================================>
       #+end_src
     + 所以我们要用到另外一个flag VERBOSE,能够把表达式描写的更易于阅读一点
       #+begin_src python
         import re
         
         address = re.compile(
             '''
             [\w\d.+-]+         # username
             @  
             ([\w\d.]+\.)+      # domain name prefix
             (com|org|edu)      # TODO: suppor tomore top-level domains
             ''',
             re.UNICODE | re.VERBOSE)
         
         candidates = [
             u'first.last@example.com',
             u'first.last+category@gmail.com',
             u'valid-address@mail.example.com',
             u'not-valid@example.foo',
             ]
         
         for candidate in candidates:
             match = address.search(candidate)
             print '%-30s %s' % (candidate, 'Matches' if match else 'NO match')
         
         # Output:
         # <==================================================================
         # first.last@example.com         Matches
         # first.last+category@gmail.com  Matches
         # valid-address@mail.example.com Matches
         # not-valid@example.foo          NO match 
         # ==================================================================>
       #+end_src
     + 下面的例子是分析更复杂的email地址,比如 First Last <first.last@example.com>这种,先写上
       自己的姓名,然后用<>包括上email地址
       #+begin_src python
         import re
         
         address = re.compile(
             '''
             # A name is made up of letters, and my include "."
             # for title abbreviations and middle initials.
             ((?P<name>
                ([\w.,]+\s+)*[\w.,]+)
                \s*
                # Email addresses are wrapped in angle
                # brackets: < > but only if a name is 
                # found, so keep the start bracket in this
                # group
                <
              )? # the entire name is optional
         
              # The address itself: username@domain.tld
              (?P<email>
                [\w\d.+-]+        #username
                @
                ([\w\d.]+\.)+     #domain name prefix
                (com|org|edu)     #limit the allowed top-level domains
              )
         
              >?  # optional closing angle bracket
              ''',
              re.UNICODE | re.VERBOSE)
         
         candidates = [
             u'first.last@example.com',
             u'first.last+category@gmail.com',
             u'valid-address@mail.example.com',
             u'not-valid@example.foo',
             u'First Last <first.last@example.com>',
             u'No Brackets first.last@example.com',
             u'Fisrt Last',
             u'Fisrt Middle Last <first.last@example.com>',
             u'First M. Last <first.last@example.com>',
             u'<first.last@example.com>',
             ]
         
         for candidate in candidates:
             print 'Candidate:', candidate
             match = address.search(candidate)
             if match:
                 print ' Name  :', match.groupdict()['name']
                 print ' Email :', match.groupdict()['email']
             else:
                 print ' No match'
         
         # Output:
         # <==================================================================
         # Candidate: first.last@example.com
         #  Name  : None
         #  Email : first.last@example.com
         # Candidate: first.last+category@gmail.com
         #  Name  : None
         #  Email : first.last+category@gmail.com
         # Candidate: valid-address@mail.example.com
         #  Name  : None
         #  Email : valid-address@mail.example.com
         # Candidate: not-valid@example.foo
         #  No match
         # Candidate: First Last <first.last@example.com>
         #  Name  : First Last
         #  Email : first.last@example.com
         # Candidate: No Brackets first.last@example.com
         #  Name  : None
         #  Email : first.last@example.com
         # Candidate: Fisrt Last
         #  No match
         # Candidate: Fisrt Middle Last <first.last@example.com>
         #  Name  : Fisrt Middle Last
         #  Email : first.last@example.com
         # Candidate: First M. Last <first.last@example.com>
         #  Name  : First M. Last
         #  Email : first.last@example.com
         # Candidate: <first.last@example.com>
         #  Name  : None
         #  Email : first.last@example.com
         # ==================================================================>
       #+end_src
**** Embedding Flags in Patterns
     + 如果某些情况下,不允许在re函数里面添加第二个参数flag,可以把参数加在patter里面,比如下面的
       r'(?i)\bT\w+'
       #+begin_src python
         import re
         
         text = 'This is some text -- with punctuation.'
         pattern = r'(?i)\bT\w+'
         regex = re.compile(pattern)
         
         print 'Text    :', text
         print 'Pattern :', pattern
         print 'Matches :', regex.findall(text)
         
         # Output:
         # <==================================================================
         # Text    : This is some text -- with punctuation.
         # Pattern : (?i)\bT\w+
         # Matches : ['This', 'text']
         # ==================================================================>
       #+end_src
     + 所有search option的小写字母版总结如下
       | Flag       | Abbreviation |
       |------------+--------------|
       | IGNORECASE | i            |
       | MULTILINE  | m            |
       | DOTALL     | s            |
       | UNICODE    | u            |
       | VERBOSE    | x            | 
*** Looking Ahead or Behind
    + 原来的对于<adimin@example.com>的做法是把"<"放到一个group里面,然后标记成optional(用?), 
      但是其实这个括号并不是可有可无,而是必须成对出现!这个时候positive look-ahead(肯定前向)
      就用作用了,在python的做法就是(?=pattern)
      #+begin_src python
        import re
        
        address = re.compile(
            '''
            ((?P<name>
               ([\w.,]+\s+)*[\w.,]+
             )
             \s+
            ) #name is no longer optional
        
            # LOOKAHEAD
            # Email addresses are wrapped in angle brackets, but only
            # if they are both present or neither is.
            (?= (<.*>$)
                |
                ([^<].*[^>]$)
                )
        
             <? #optional opening angle bracket
        
             (?P<email>
                [\w\d.+-]+
                @
                ([\w\d.]+\.)+
                (com|org|edu)
             )
        
             >?  #optional closing angle bracket
             ''',
             re.UNICODE | re.VERBOSE)
        
        candidates = [
            u'First Last <first.last@example.com>',
            u'No Brackets first.last@example.com',
            u'Open Bracket <first.last@example.com',
            u'Close Bracket firs.last@example.com>',
            ]
        
        for candidate in candidates:
            print 'Candidate:', candidate
            match = address.search(candidate)
            if match:
                print '   Name :', match.groupdict()['name']
                print '   Email:', match.groupdict()['email']
            else:
                print '   No match'
        
        # Output:
        # <==================================================================
        # Candidate: First Last <first.last@example.com>
        #    Name : First Last
        #    Email: first.last@example.com
        # Candidate: No Brackets first.last@example.com
        #    Name : No Brackets
        #    Email: first.last@example.com
        # Candidate: Open Bracket <first.last@example.com
        #    No match
        # Candidate: Close Bracket firs.last@example.com>
        #    No match 
        # ==================================================================>
      #+end_src
    + 还可以用negative look-ahead(否定前向)来忽略某些匹配,比如常见的noreply, 使用(?!pattern)
      #+begin_src python
        import re
        
        address = re.compile(
            '''
            ^
            #Ignore noreply address
            (?!noreply@.*$)
        
            [\w\d.+-]+      #username
            @
            ([\w\d.]+\.)    #limit the allowed top-level domains
        
            $
            ''',
            re.UNICODE | re.VERBOSE)
        
        
        candidates = [
            u'first.last@example.com',
            u'noreply@example.com',
            ]
        
        for candidate in candidates:
            print 'Candidate:', candidate
            match = address.search(candidate)
            if match:
                print 'MATCHES:', candidate[match.start():match.end()]
            else:
                print 'No Match:'
        
        # Output:
        # <==================================================================
        # Candidate: first.last@example.com
        # No Match:
        # Candidate: noreply@example.com
        # No Match:
        # ==================================================================>
      #+end_src
    + 除了前两种方法还有两种,一个是negative look-behind(否定后向), 还有一种是positive 
      look-behind(肯定后向), 好绕口...先看否定后向(?<!pattern)
      #+begin_src python
        import re
        
        address = re.compile(
            '''
            ^
            [\w\d.+-]+         # username
        
            #Ignore noreply address
            (?<!noreply)
        
            @
            ([\w\d.]+\.)+      # domain name prefix
            (com|org|edu)     #limit the allowed top-level domains
        
            $
            ''',
            re.UNICODE | re.VERBOSE)
        
        candidates = [
            u'first.last@example.com',
            u'noreply@example.com',
            ]
        
        for candidate in candidates:
            print 'Candidate:', candidate
            match = address.search(candidate)
            if match:
                print '   Match:', candidate[match.start():match.end()]
            else:
                print '   No match'
        
        # Output:
        # <==================================================================
        # Candidate: first.last@example.com
        #    Match: first.last@example.com
        # Candidate: noreply@example.com
        #    No match
        # ==================================================================>
      #+end_src
    + 最后就剩下positive look-behind(肯定后向)了,它可以用来寻找比如pattern后面是一个正则表达式
      的情况,比如 patternABCD 就可以 (?<=pattern)来设置他们的前缀.
      #+begin_src python
        import re
        
        twitter = re.compile(
            '''
            # A twitter handle: @username
            (?<=@)
            ([\w\d_]+)
            ''',
            re.UNICODE | re.VERBOSE)
        
        text = ''' This text includes two Twitter handles.
        One for @ThePSF, and one for the author, @doughellmann.
        '''
        
        print text
        for match in twitter.findall(text):
            print 'Handle:', match
        
        # Output:
        # <==================================================================
        # This text includes two Twitter handles.
        # One for @ThePSF, and one for the author, @doughellmann.
        # 
        # Handle: ThePSF
        # Handle: doughellmann
        # ===========================================================================>
      #+end_src
*** Self-Referencing Expressions
    + 我们可以用"\数字"的方法来创建反向引用,但是缺点明显:只能创建99个引用, 表达式改变也要随着改变
      #+begin_src python
        import re
        
        address = re.compile(
            r'''
            (\w+)              #first name
            \s+
            (([\w.]+)\s+)?     #optional middle name or initial
            (\w+)              #last name
        
            \s+ 
        
            <
        
            #The address: first_name.last_name@domain.tld
            (?P<email>
            \1               #first name
            \. 
            \4               #last name
            @
            ([\w\d.]+\.)+    #domain name prefix
            (com|org|edu)    #limit the allowed top-level domains
            )
        
            >
            ''',
            re.UNICODE | re.VERBOSE | re.IGNORECASE)
        
        candidates = [
            u'First Last <first.last@example.com>',
            u'Different Name <first.last@example.com>',
            u'First Middle Last <first.last@example.com>',
            u'Fisrt M. Last <first.last@example.com>',
            ]
        
        for candidate in candidates:
            print 'Candidate:', candidate
            match = address.search(candidate)
            if match:
                print '   Match name  :', match.group(1), match.group(4)
                print '   Match email :', match.group(5)
            else:
                print '   No match'
        
        # Output:
        # <==================================================================
        # Candidate: First Last <first.last@example.com>
        #    Match name  : First Last
        #    Match email : first.last@example.com
        # Candidate: Different Name <first.last@example.com>
        #    No match
        # Candidate: First Middle Last <first.last@example.com>
        #    Match name  : First Last
        #    Match email : first.last@example.com
        # Candidate: Fisrt M. Last <first.last@example.com>
        #    No match
        # ==================================================================>
      #+end_src
    + 还有个叫做(?P=name)的方法来指代先前匹配的一个值.
      #+begin_src python
        import re
        
        address = re.compile(
            '''
            #The regular name
            (?P<first_name>\w+)
            \s+
            (([\w.]+)\s+)?  
            (?P<last_name>\w+)
        
            \s+
        
            <
        
            (?P<email>
              (?P=first_name)
              \.
              (?P=last_name)
              @
              ([\w\d.]+\.)+   #domain name prefix
              (com|org|edu)   #limit the allowed top-level domains
            )
        
            >
            ''',
            re.UNICODE | re.VERBOSE | re.IGNORECASE)
        
        candidates = [
            u'First Last <first.last@example.com>',
            u'Different Name <first.last@example.com>',
            u'First Middle Last <first.last@example.com>',
            u'First M. Last <first.last@example.com>',
            ]
        
        for candidate in candidates:
            print 'Candidate:', candidate
            match = address.search(candidate)
            if match:
                print ' Match name  :', match.groupdict()['first_name'],
                print match.groupdict()['last_name']
                print ' Match email :', match.groupdict()['email']
            else:
                print ' No match'
        
        # Output:
        # <==================================================================
        # Candidate: First Last <first.last@example.com>
        #  Match name  : First Last
        #  Match email : first.last@example.com
        # Candidate: Different Name <first.last@example.com>
        #  No match
        # Candidate: First Middle Last <first.last@example.com>
        #  Match name  : First Last
        #  Match email : first.last@example.com
        # Candidate: First M. Last <first.last@example.com>
        #  Match name  : First Last
        #  Match email : first.last@example.com 
        # ==================================================================>
      #+end_src
    + 另外的用法就是根据前面的一个group是否match来决定使用哪种pattern
      #+begin_src python
        import re
        
        address = re.compile(
            '''
            ^
        
            # A name is made up of letters, and may include "."
            # for title abbreviations and middle initials.
            (?P<name>
                ([\w.]+\s+)*[\w.]+
              )?
            \s*
        
            # Email addresses are wrapped in angel brackets, but
            # only if a name is found.
            (?(name)
              # remainder wrapped in angel brackets because
              # there is a name
              (?P<brackets>(?=(<.*>$)))
              |
              # remainder does not inculude angel brackets without name
              (?=([^<].*[^>]$))
            )
        
            # Only look for a bracket if the look-ahead assertion
            # found both of them.
            (?(brackets)<|\s*)
        
            # The address itself: usrname@domain.tld
            (?P<email>
               [\w\d.+-]+        
               @
               ([\w\d.]+\.)+
               (com|org|edu)
            )
        
            # Only look for a bracket if the look-ahead assertion
            # found both of them.
            (?(brackets)>|\s*)
        
             $
             ''',
             re.UNICODE | re.VERBOSE)
        
        candidates = [
            u'First Last <first.last@example.com>',
            u'No Brackets first.last@example.com',
            u'Open Bracket <first.last@example.com',
            u'Close Bracket firs.last@example.com>',
            u'no.brackets@example.com',
            ]
        
        for candidate in candidates:
            print 'Candidate:', candidate
            match = address.search(candidate)
            if match:
                print '   Match name  :', match.groupdict()['name']
                print '   Match email :', match.groupdict()['email']
            else:
                print '   No match'
        
        # Output:
        # <==================================================================
        # Candidate: First Last <first.last@example.com>
        #    Match name  : First Last
        #    Match email : first.last@example.com
        # Candidate: No Brackets first.last@example.com
        #    No match
        # Candidate: Open Bracket <first.last@example.com
        #    No match
        # Candidate: Close Bracket firs.last@example.com>
        #    No match
        # Candidate: no.brackets@example.com
        #    Match name  : None
        #    Match email : no.brackets@example.com 
        # ==================================================================>
      #+end_src
*** Modifying Strings with Patterns
    + 除了查找, re还支持替换,如下
      #+begin_src python
        import re
        
        bold = re.compile(r'\*{2}(.*?)\*{2}')
        
        text = 'Make this **bold**. This **too**.'
        
        print 'Text:', text
        print 'Bold:', bold.sub(r'<b>\1</b>', text)
        
        # Output:
        # <==================================================================
        # Text: Make this **bold**. This **too**.
        # Bold: Make this <b>bold</b>. This <b>too</b>.
        # ==================================================================>
      #+end_src
    + 下面是named group在替换时候的使用方法
      #+begin_src python
        import re
        
        bold = re.compile(r'\*{2}(?P<bold_text>.*?)\*{2}', re.UNICODE)
        
        text = 'Make this **bold**. This **too**.'
        
        print 'Text:', text
        # use name other than 1 to make it more clear
        print 'Bold:', bold.sub(r'<b>\g<bold_text></b>', text)
        
        # Output:
        # <==================================================================
        # Text: Make this **bold**. This **too**.
        # Bold: Make this <b>bold</b>. This <b>too</b>.
        # ==================================================================>
      #+end_src
    + 前面没有用named group而是用了数字,就是代表替代的次数,下例有两处匹配,但是
      因为count的数字是1,所以只替换了第一次的结果
      #+begin_src python
        import re
        
        bold = re.compile(r'\*{2}(.*?)\*{2}', re.UNICODE)
        
        text = 'Make this **bold**. This **too**.'
        
        print 'Text:', text
        print 'Bold:', bold.sub(r'<b>\1</b>', text, count=1)
        
        # Output:
        # <==================================================================
        # Text: Make this **bold**. This **too**.
        # Bold: Make this <b>bold</b>. This **too**.
        # Text: Make this **bold**. This **too**.
        # Bold: Make this <b>bold</b>. This **too**.
        # ==================================================================>
      #+end_src




            
        




    

       












      
       
       
      
       
      
      
      
       
